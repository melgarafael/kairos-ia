{
  "version": "v58",
  "migrations": [
    {
      "id": "000_bootstrap_migrations_table",
      "name": "Ensure tomikcrm_schema_migrations table",
      "checksum": "",
      "sql": "create table if not exists public.tomikcrm_schema_migrations (id text primary key, name text not null, version text, checksum text, status text not null default 'applied', applied_at timestamptz not null default now());"
    },
    {
      "id": "v010_repositorio_de_mensagens_rls",
      "name": "v10 - repositorio_de_mensagens: org, RLS e RPC",
      "checksum": "",
      "sql": "-- v10 – Repositório de mensagens: adicionar organization_id, RLS por organização e ajustar RPC\n\n-- Adicionar coluna organization_id\nalter table if exists public.repositorio_de_mensagens\n  add column if not exists organization_id uuid;\n\n-- Trigger para preencher organization_id a partir do contexto se nulo\ncreate or replace function public.rm_set_org_from_context()\nreturns trigger\nlanguage plpgsql\nas $$\nbegin\n  if new.organization_id is null then\n    begin\n      new.organization_id := nullif(current_setting('app.organization_id', true), '')::uuid;\n    exception when others then\n      -- ignora\n      new.organization_id := new.organization_id;\n    end;\n  end if;\n  return new;\nend;\n$$;\n\ndrop trigger if exists trg_rm_set_org_from_context on public.repositorio_de_mensagens;\ncreate trigger trg_rm_set_org_from_context\nbefore insert on public.repositorio_de_mensagens\nfor each row execute function public.rm_set_org_from_context();\n\n-- Índice por organização + created_at\ncreate index if not exists repositorio_de_mensagens_org_created_idx\n  on public.repositorio_de_mensagens(organization_id, created_at desc);\n\n-- Atualizar RLS: restringir por organização\nalter table public.repositorio_de_mensagens enable row level security;\n\n-- Remover políticas antigas permissivas, se existirem\ndo $$ begin\n  if exists (select 1 from pg_policies where schemaname='public' and tablename='repositorio_de_mensagens' and policyname='rm_select_authenticated') then\n    drop policy rm_select_authenticated on public.repositorio_de_mensagens;\n  end if;\n  if exists (select 1 from pg_policies where schemaname='public' and tablename='repositorio_de_mensagens' and policyname='rm_modify_authenticated') then\n    drop policy rm_modify_authenticated on public.repositorio_de_mensagens;\n  end if;\nend $$;\n\n-- Criar políticas por organização (authenticated)\ndo $$ begin\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='repositorio_de_mensagens' and policyname='rm_select_by_org'\n  ) then\n    create policy rm_select_by_org on public.repositorio_de_mensagens\n      for select to authenticated\n      using (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='repositorio_de_mensagens' and policyname='rm_insert_by_org'\n  ) then\n    create policy rm_insert_by_org on public.repositorio_de_mensagens\n      for insert to authenticated\n      with check (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='repositorio_de_mensagens' and policyname='rm_update_by_org'\n  ) then\n    create policy rm_update_by_org on public.repositorio_de_mensagens\n      for update to authenticated\n      using (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      ) with check (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\nend $$;\n\n-- Ajustar RPC rm_buscar para filtrar por organização\ndrop function if exists public.rm_buscar(timestamptz, timestamptz, sender_type, text, text, int, int);\n\ncreate or replace function public.rm_buscar(\n  p_inicio timestamptz,\n  p_fim timestamptz,\n  p_sender sender_type default null,\n  p_numero text default null,\n  p_query text default null,\n  p_limit int default 100,\n  p_offset int default 0,\n  p_org uuid default null\n)\nreturns setof public.repositorio_de_mensagens\nlanguage sql\nstable\nas $$\n  select *\n  from public.repositorio_de_mensagens m\n  where m.created_at between coalesce(p_inicio, '-infinity') and coalesce(p_fim, 'infinity')\n    and (p_sender is null or m.sender_type = p_sender)\n    and (p_numero is null or m.whatsapp_cliente = p_numero or m.whatsapp_empresa = p_numero)\n    and (\n      p_query is null\n      or m.tsv @@ websearch_to_tsquery('portuguese', p_query)\n    )\n    and (\n      m.organization_id is not null\n      and m.organization_id = coalesce(p_org, nullif(current_setting('app.organization_id', true), '')::uuid)\n    )\n  order by m.created_at desc\n  limit greatest(0, p_limit)\n  offset greatest(0, p_offset)\n$$;\n\n-- Backfill simples: se existir exatamente 1 organização, atribuí-la aos registros nulos\ndo $$\ndeclare v_org uuid; v_count int; begin\n  select count(*), min(id) into v_count, v_org from public.saas_organizations;\n  if v_count = 1 then\n    update public.repositorio_de_mensagens set organization_id = v_org where organization_id is null;\n  end if;\nend $$;\n\n-- Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('10', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v011_repositorio_de_mensagens_not_null",
      "name": "v11 - repositorio_de_mensagens: NOT NULLs + set_rls_context",
      "checksum": "",
      "sql": "-- v11 – Ajuste de NOT NULL em repositorio_de_mensagens\n-- Requisito: apenas whatsapp_cliente, sender_type e content_text devem ser NOT NULL\n\n-- 1) Backfill seguro para evitar falhas ao aplicar NOT NULL\nupdate public.repositorio_de_mensagens\nset content_text = ''\nwhere content_text is null;\n\nupdate public.repositorio_de_mensagens\nset whatsapp_cliente = ''\nwhere whatsapp_cliente is null;\n\ndo $$\nbegin\n  -- Se sender_type estiver nulo, assumir 'cliente'\n  update public.repositorio_de_mensagens\n  set sender_type = 'cliente'::sender_type\n  where sender_type is null;\nexception when others then\n  -- ignorar caso o enum não exista por algum motivo\n  null;\nend $$;\n\n-- 2) Definir defaults mínimos (opcional mas útil)\nalter table if exists public.repositorio_de_mensagens\n  alter column content_text set default '';\n\n-- 3) Tornar APENAS estes campos obrigatórios\nalter table if exists public.repositorio_de_mensagens\n  alter column whatsapp_cliente set not null,\n  alter column sender_type set not null,\n  alter column content_text set not null;\n\n-- 4) Remover NOT NULL dos demais que tinham restrição\ndo $$\nbegin\n  -- created_at originalmente era NOT NULL\n  begin\n    alter table public.repositorio_de_mensagens alter column created_at drop not null;\n  exception when others then null; end;\n  -- whatsapp_empresa originalmente era NOT NULL\n  begin\n    alter table public.repositorio_de_mensagens alter column whatsapp_empresa drop not null;\n  exception when others then null; end;\n  -- direction originalmente era NOT NULL\n  begin\n    alter table public.repositorio_de_mensagens alter column direction drop not null;\n  exception when others then null; end;\nend $$;\n\n-- Create RPC to set organization context for RLS policies\nset search_path = public, auth;\n\n-- Drop and recreate for idempotency\ndrop function if exists public.set_rls_context(uuid);\n\ncreate or replace function public.set_rls_context(p_organization_id uuid)\nreturns void\nlanguage sql\nas $$\n  select set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n$$;\n\n-- Ensure authenticated/anon roles can execute (PostgREST)\ndo $$ begin\n  grant execute on function public.set_rls_context(uuid) to anon, authenticated;\nexception when others then\n  -- ignore if roles not present in this environment\n  null;\nend $$;\n\ncomment on function public.set_rls_context(uuid) is 'Sets app.organization_id GUC for row-level policies.';\n\n-- 5) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('11', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v012_normalize_produtos_servicos",
      "name": "v12 - Normalizar produtos_servicos (categoria/tipo/cobranca_tipo)",
      "checksum": "",
      "sql": "-- Normalize legacy values in produtos_servicos to satisfy CHECK constraints\n-- This migration maps common variants (case/accents) to the canonical values\n-- Safe to run multiple times\n\n-- Categoria: canonical set\n-- ['Consulta','Exame','Procedimento','Terapia','Cirurgia','Medicamento','Equipamento','Material','Software','Imovel','Treinamento','Outros']\nupdate public.produtos_servicos set categoria = 'Consulta' where categoria ilike 'consulta';\nupdate public.produtos_servicos set categoria = 'Exame' where categoria ilike 'exame';\nupdate public.produtos_servicos set categoria = 'Procedimento' where categoria ilike 'procedimento';\nupdate public.produtos_servicos set categoria = 'Terapia' where categoria ilike 'terapia';\nupdate public.produtos_servicos set categoria = 'Cirurgia' where categoria ilike 'cirurgia';\nupdate public.produtos_servicos set categoria = 'Medicamento' where categoria ilike 'medicamento';\nupdate public.produtos_servicos set categoria = 'Equipamento' where categoria ilike 'equipamento';\nupdate public.produtos_servicos set categoria = 'Material' where categoria ilike 'material';\nupdate public.produtos_servicos set categoria = 'Software' where categoria ilike 'software';\n-- Handle accented/improper forms for Imovel\nupdate public.produtos_servicos set categoria = 'Imovel' where categoria in ('Imóvel','imóvel','Imovel','imovel');\nupdate public.produtos_servicos set categoria = 'Treinamento' where categoria ilike 'treinamento';\nupdate public.produtos_servicos set categoria = 'Outros' where categoria ilike 'outros';\n\n-- Anything else -> Outros\nupdate public.produtos_servicos\n   set categoria = 'Outros'\n where categoria not in ('Consulta','Exame','Procedimento','Terapia','Cirurgia','Medicamento','Equipamento','Material','Software','Imovel','Treinamento','Outros');\n\n-- Tipo: canonical set\n-- ['produto','servico','consultoria','assinatura','curso','evento','imovel','software']\nupdate public.produtos_servicos set tipo = 'produto' where lower(tipo) in ('produto','produtos');\nupdate public.produtos_servicos set tipo = 'servico' where lower(tipo) in ('servico','serviço','servicos','serviços');\nupdate public.produtos_servicos set tipo = 'consultoria' where lower(tipo) like 'consultoria%';\nupdate public.produtos_servicos set tipo = 'assinatura' where lower(tipo) like 'assinatura%';\nupdate public.produtos_servicos set tipo = 'curso' where lower(tipo) like 'curso%';\nupdate public.produtos_servicos set tipo = 'evento' where lower(tipo) like 'evento%';\nupdate public.produtos_servicos set tipo = 'imovel' where lower(tipo) in ('imovel','imóvel','imoveis','imóveis');\nupdate public.produtos_servicos set tipo = 'software' where lower(tipo) like 'software%';\n\n-- Fallback para valores fora do conjunto\nupdate public.produtos_servicos\n   set tipo = 'servico'\n where lower(tipo) not in ('produto','servico','serviço','consultoria','assinatura','curso','evento','imovel','imóvel','software');\n\n-- Cobranca_tipo: canonical set\n-- ['unica','mensal','trimestral','semestral','anual']\nupdate public.produtos_servicos set cobranca_tipo = 'unica' where lower(cobranca_tipo) in ('unica','única');\nupdate public.produtos_servicos set cobranca_tipo = 'mensal' where lower(cobranca_tipo) like 'mensal%';\nupdate public.produtos_servicos set cobranca_tipo = 'trimestral' where lower(cobranca_tipo) like 'trimestral%';\nupdate public.produtos_servicos set cobranca_tipo = 'semestral' where lower(cobranca_tipo) like 'semestral%';\nupdate public.produtos_servicos set cobranca_tipo = 'anual' where lower(cobranca_tipo) like 'anual%';\n\n-- Fallback para valores fora do conjunto\nupdate public.produtos_servicos\n   set cobranca_tipo = 'unica'\n where lower(cobranca_tipo) not in ('unica','única','mensal','trimestral','semestral','anual');\n\n-- 5) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('12', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v013_instagram_username_crm_leads",
      "name": "v13 - Add instagram_username to crm_leads",
      "checksum": "",
      "sql": "-- Add optional Instagram username to crm_leads\nalter table if exists public.crm_leads\n  add column if not exists instagram_username text;\n\ncomment on column public.crm_leads.instagram_username is 'Instagram @username of the lead';\n\n\n-- 5) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('13', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v014_james_rls",
      "name": "v14 - James: tabela + RLS + RPC",
      "checksum": "",
      "sql": "-- James (ElevenLabs agent linkage) per organization\n\ncreate table if not exists public.james (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid not null,\n  agent_id text not null,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  unique (organization_id)\n);\n\ncreate index if not exists idx_james_org on public.james (organization_id);\n\nalter table public.james enable row level security;\n\n-- Shared helper to keep updated_at fresh (idempotent)\ncreate or replace function public.set_updated_at()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\ndrop trigger if exists set_timestamp_on_james on public.james;\ncreate trigger set_timestamp_on_james\nbefore update on public.james\nfor each row execute function public.set_updated_at();\n\n-- RLS policies by organization context (requires set_rls_context to be called)\ndo $$\nbegin\n  if not exists (\n    select 1 from pg_policies where schemaname = 'public' and tablename = 'james' and policyname = 'james_select_own_org'\n  ) then\n    create policy james_select_own_org on public.james\n      for select to anon, authenticated\n      using (\n        organization_id is not null\n        and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n      );\n  end if;\n\n  if not exists (\n    select 1 from pg_policies where schemaname = 'public' and tablename = 'james' and policyname = 'james_modify_own_org'\n  ) then\n    create policy james_modify_own_org on public.james\n      for all to anon, authenticated\n      using (\n        organization_id is not null\n        and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n      )\n      with check (\n        organization_id is not null\n        and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n      );\n  end if;\nend $$;\n\n-- Helper RPCs atômicos (setam contexto e operam na mesma call)\ncreate or replace function public.james_get(p_organization_id uuid)\nreturns table(agent_id text)\nlanguage plpgsql security definer\nas $$\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n  return query\n    select j.agent_id\n    from public.james j\n    where j.organization_id = p_organization_id\n    limit 1;\nend;\n$$;\ngrant execute on function public.james_get(uuid) to anon, authenticated;\n\ncreate or replace function public.james_upsert(p_organization_id uuid, p_agent_id text)\nreturns void\nlanguage plpgsql security definer\nas $$\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n  insert into public.james (organization_id, agent_id)\n  values (p_organization_id, coalesce(p_agent_id, ''))\n  on conflict (organization_id) do update\n    set agent_id = excluded.agent_id,\n        updated_at = now();\nend;\n$$;\ngrant execute on function public.james_upsert(uuid, text) to anon, authenticated;\n\n\n-- 2) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('14', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v015_n8n_connections_org_rpcs",
      "name": "v15 - n8n connections por organização + RLS + RPCs",
      "checksum": "",
      "sql": "-- v15 – n8n connections per organization + RPCs (security definer)\n\ncreate table if not exists public.n8n_connections (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid not null,\n  base_url text not null,\n  api_key text not null,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  unique (organization_id)\n);\n\ncreate index if not exists idx_n8n_connections_org on public.n8n_connections (organization_id);\n\nalter table public.n8n_connections enable row level security;\n\ncreate or replace function public.set_updated_at()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend; $$ language plpgsql;\n\ndrop trigger if exists trg_n8n_conn_updated_at on public.n8n_connections;\ncreate trigger trg_n8n_conn_updated_at before update on public.n8n_connections\nfor each row execute function public.set_updated_at();\n\ndo $$\nbegin\n  if not exists (select 1 from pg_policies where tablename='n8n_connections' and policyname='n8n_conn_select') then\n    create policy n8n_conn_select on public.n8n_connections\n      for select to anon, authenticated\n      using (organization_id::text = nullif(current_setting('app.organization_id', true), ''));\n  end if;\n  if not exists (select 1 from pg_policies where tablename='n8n_connections' and policyname='n8n_conn_modify') then\n    create policy n8n_conn_modify on public.n8n_connections\n      for all to anon, authenticated\n      using (organization_id::text = nullif(current_setting('app.organization_id', true), ''))\n      with check (organization_id::text = nullif(current_setting('app.organization_id', true), ''));\n  end if;\nend $$;\n\n-- Atomic RPCs\ncreate or replace function public.n8n_get(p_organization_id uuid)\nreturns table(base_url text, api_key text)\nlanguage plpgsql security definer as $$\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n  return query select c.base_url, c.api_key from public.n8n_connections c where c.organization_id = p_organization_id limit 1;\nend; $$;\ngrant execute on function public.n8n_get(uuid) to anon, authenticated;\n\ncreate or replace function public.n8n_upsert(p_organization_id uuid, p_base_url text, p_api_key text)\nreturns void\nlanguage plpgsql security definer as $$\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n  insert into public.n8n_connections (organization_id, base_url, api_key)\n  values (p_organization_id, p_base_url, p_api_key)\n  on conflict (organization_id) do update set base_url = excluded.base_url, api_key = excluded.api_key, updated_at = now();\nend; $$;\ngrant execute on function public.n8n_upsert(uuid, text, text) to anon, authenticated;\n\n\n-- 2) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('15', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v016_crm_lead_activities_field_changed",
      "name": "v16 - CRM Lead Activities: field_changed e descrição precisa",
      "checksum": "",
      "sql": "--\n-- CRM Lead Activities: add field_changed and log description changes\n--\n-- This migration updates the audit trail for leads so that it records\n-- specific field changes (starting with stage and description), avoiding\n-- misleading entries where old/new values repeat when nothing changed.\n\n-- 1) Schema: add column field_changed\nalter table if exists public.crm_lead_activities\n  add column if not exists field_changed text;\n\n-- 2) Logic: update trigger function to log per-field changes\ncreate or replace function public.log_crm_lead_changes()\nreturns trigger\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  v_actor uuid;\n  v_any_inserted boolean := false;\nbegin\n  v_actor := coalesce(new.updated_by, new.created_by, old.updated_by, old.created_by);\n\n  if tg_op = 'INSERT' then\n    -- Lead created\n    insert into public.crm_lead_activities (\n      lead_id, user_id, action, field_changed, description, created_at\n    ) values (\n      new.id, v_actor, 'INSERT', 'insert', 'Lead criado: ' || coalesce(new.name,''), now()\n    );\n    return new;\n\n  elsif tg_op = 'UPDATE' then\n    -- Stage change\n    if old.stage is distinct from new.stage then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'stage',\n        'Lead movido para: ' || coalesce(new.stage,'indefinido'),\n        old.stage, new.stage, now()\n      );\n      v_any_inserted := true;\n    end if;\n\n    -- Description change\n    if coalesce(old.description,'') is distinct from coalesce(new.description,'') then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'description',\n        'Descrição atualizada',\n        old.description, new.description, now()\n      );\n      v_any_inserted := true;\n    end if;\n\n    -- Payment status change (keep as meaningful event)\n    if coalesce(old.has_payment,false) is distinct from coalesce(new.has_payment,false) then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'has_payment',\n        case when new.has_payment then 'Lead marcado como pago' else 'Lead desmarcado como pago' end,\n        coalesce(old.payment_value,0)::text,\n        coalesce(new.payment_value,0)::text,\n        now()\n      );\n      v_any_inserted := true;\n    elsif coalesce(old.payment_value,0) is distinct from coalesce(new.payment_value,0) then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'payment_value',\n        'Valor do pagamento atualizado',\n        coalesce(old.payment_value,0)::text,\n        coalesce(new.payment_value,0)::text,\n        now()\n      );\n      v_any_inserted := true;\n    end if;\n\n    -- Fallback generic update (only if nothing above was logged)\n    if not v_any_inserted then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', null, 'Lead atualizado: ' || coalesce(new.name,''), now()\n      );\n    end if;\n\n    return new;\n\n  elsif tg_op = 'DELETE' then\n    insert into public.crm_lead_activities (\n      lead_id, user_id, action, field_changed, description, created_at\n    ) values (\n      old.id, v_actor, 'DELETE', 'delete', 'Lead excluído: ' || coalesce(old.name,''), now()\n    );\n    return old;\n  end if;\n\n  return new;\nexception when others then\n  -- Non-critical; don't block writes\n  raise notice 'CRM lead activity logging failed: %', sqlerrm;\n  if tg_op = 'DELETE' then\n    return old;\n  else\n    return new;\n  end if;\nend;\n$$;\n\n-- 3) Ensure trigger exists (idempotent)\ndrop trigger if exists crm_lead_activity_trigger on public.crm_leads;\ncreate trigger crm_lead_activity_trigger\n  after insert or update or delete on public.crm_leads\n  for each row execute function public.log_crm_lead_changes();\n\n-- 2) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('16', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v017_monetization_trail_progress",
      "name": "v17 – Trilha de Monetização: progresso por etapa",
      "checksum": "",
      "sql": "-- v17 – Trilha de Monetização: progresso por etapa\n\n-- 1) Tabela de progresso por organização e etapa\ncreate table if not exists public.monetization_trail_progress (\n  organization_id uuid not null,\n  step_key text not null,\n  completed boolean not null default false,\n  completed_at timestamptz null,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  constraint monetization_trail_progress_pkey primary key (organization_id, step_key)\n);\n\n-- 2) Índices auxiliares\ncreate index if not exists monetization_trail_progress_org_idx on public.monetization_trail_progress (organization_id);\ncreate index if not exists monetization_trail_progress_completed_idx on public.monetization_trail_progress (completed);\n\n-- 3) Trigger para updated_at\ncreate or replace function public.set_updated_at()\nreturns trigger\nlanguage plpgsql\nas $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$;\n\ndrop trigger if exists monetization_trail_progress_set_updated_at on public.monetization_trail_progress;\ncreate trigger monetization_trail_progress_set_updated_at\nbefore update on public.monetization_trail_progress\nfor each row execute function public.set_updated_at();\n\n-- 4) RLS por organização (usa app.organization_id configurado via RPC set_rls_context)\nalter table public.monetization_trail_progress enable row level security;\n\ndrop policy if exists \"trail_read_org\" on public.monetization_trail_progress;\ncreate policy \"trail_read_org\" on public.monetization_trail_progress\n  for select to authenticated\n  using ((organization_id::text = current_setting('app.organization_id', true)));\n\ndrop policy if exists \"trail_write_org\" on public.monetization_trail_progress;\ncreate policy \"trail_write_org\" on public.monetization_trail_progress\n  for insert to authenticated\n  with check ((organization_id::text = current_setting('app.organization_id', true)));\n\ndrop policy if exists \"trail_update_org\" on public.monetization_trail_progress;\ncreate policy \"trail_update_org\" on public.monetization_trail_progress\n  for update to authenticated\n  using ((organization_id::text = current_setting('app.organization_id', true)))\n  with check ((organization_id::text = current_setting('app.organization_id', true)));\n\n-- 5) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('17', now())\non conflict (version) do nothing;"
    }
    ,
    {
      "id": "v018_n8n_delete_rpc",
      "name": "v18 – RPC para remover conexão do n8n por organização",
      "checksum": "",
      "sql": "-- v18 – RPC para remover conexão do n8n por organização\n\ncreate or replace function public.n8n_delete(p_organization_id uuid)\nreturns void\nlanguage plpgsql\nsecurity definer\nas $$\nbegin\n  -- Setar o contexto de organização para cumprir as policies RLS\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n\n  -- Remover a conexão vinculada\n  delete from public.n8n_connections c\n  where c.organization_id = p_organization_id;\nend; $$;\n\ngrant execute on function public.n8n_delete(uuid) to anon, authenticated;\n\n-- 5) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('18', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v019_webhook_event_types_catalog",
      "name": "v19 – Catálogo webhook_event_types + RLS/policy pública",
      "checksum": "",
      "sql": "-- Ensure webhook_event_types exists and is populated with a complete catalog\n-- Safe to run multiple times; uses IF NOT EXISTS and ON CONFLICT guards\n\nset search_path = public, auth;\n\n-- 1) Table\ncreate table if not exists public.webhook_event_types (\n  id uuid primary key default gen_random_uuid(),\n  event_type text unique not null,\n  display_name text not null,\n  description text not null,\n  example_payload jsonb not null default '{}'::jsonb,\n  category text not null,\n  is_active boolean not null default true,\n  created_at timestamptz not null default now()\n);\n\n-- 2) RLS + public SELECT policy\nalter table public.webhook_event_types enable row level security;\n\ndo $$\nbegin\n  if not exists (\n    select 1 from pg_policies\n    where schemaname = 'public'\n      and tablename = 'webhook_event_types'\n      and policyname = 'Event types são públicos'\n  ) then\n    create policy \"Event types são públicos\"\n      on public.webhook_event_types\n      for select\n      to public\n      using (true);\n  end if;\nend $$;\n\n-- 3) Helpful index\ncreate index if not exists webhook_event_types_category_idx\n  on public.webhook_event_types(category);\n\n-- 4) Catalog (UPSERT)\ninsert into public.webhook_event_types (event_type, display_name, description, example_payload, category, is_active)\nvalues\n  -- CRM & Leads\n  ('lead_created', 'Lead Criado', 'Disparado quando um lead é adicionado ao CRM', '{\"event_type\":\"lead_created\",\"lead\":{\"id\":\"...\"}}'::jsonb, 'crm', true),\n  ('lead_updated', 'Lead Atualizado', 'Disparado quando dados do lead são modificados', '{\"event_type\":\"lead_updated\",\"lead\":{\"id\":\"...\"}}'::jsonb, 'crm', true),\n  ('lead_stage_changed', 'Lead Mudou Etapa', 'Quando o lead muda de etapa no funil', '{\"event_type\":\"lead_stage_changed\",\"lead\":{\"id\":\"...\"},\"old_stage\":\"novo\",\"new_stage\":\"contato\"}'::jsonb, 'crm', true),\n  ('lead_converted', 'Lead Convertido', 'Quando um lead vira cliente', '{\"event_type\":\"lead_converted\",\"lead\":{\"id\":\"...\"},\"client_id\":\"...\"}'::jsonb, 'crm', true),\n\n  -- Clientes\n  ('client_created', 'Cliente Cadastrado', 'Disparado quando um novo cliente é cadastrado', '{\"event_type\":\"client_created\",\"client\":{\"id\":\"...\"}}'::jsonb, 'clients', true),\n  ('client_updated', 'Cliente Atualizado', 'Disparado quando dados do cliente são modificados', '{\"event_type\":\"client_updated\",\"client\":{\"id\":\"...\"}}'::jsonb, 'clients', true),\n\n  -- Agendamentos\n  ('appointment_created', 'Agendamento Criado', 'Disparado quando um agendamento é criado', '{\"event_type\":\"appointment_created\",\"appointment\":{\"id\":\"...\"}}'::jsonb, 'appointments', true),\n  ('appointment_updated', 'Agendamento Atualizado', 'Disparado quando um agendamento é modificado', '{\"event_type\":\"appointment_updated\",\"appointment\":{\"id\":\"...\"}}'::jsonb, 'appointments', true),\n  ('appointment_status_changed', 'Status do Agendamento Mudou', 'Quando o status do agendamento é alterado', '{\"event_type\":\"appointment_status_changed\",\"appointment\":{\"id\":\"...\"},\"old_status\":\"agendado\",\"new_status\":\"realizado\"}'::jsonb, 'appointments', true),\n\n  -- Financeiro\n  ('payment_received', 'Pagamento Recebido', 'Disparado quando um pagamento é confirmado', '{\"event_type\":\"payment_received\",\"payment\":{\"id\":\"...\"}}'::jsonb, 'financial', true),\n\n  -- Colaboradores\n  ('collaborator_created', 'Colaborador Cadastrado', 'Disparado quando novo colaborador é adicionado', '{\"event_type\":\"collaborator_created\",\"collaborator\":{\"id\":\"...\"}}'::jsonb, 'collaborators', true),\n  ('collaborator_updated', 'Colaborador Atualizado', 'Disparado quando dados do colaborador são modificados', '{\"event_type\":\"collaborator_updated\",\"collaborator\":{\"id\":\"...\"}}'::jsonb, 'collaborators', true),\n\n  -- Produtos & Serviços\n  ('product_created', 'Produto/Serviço Criado', 'Disparado quando um item é criado', '{\"event_type\":\"product_created\",\"product\":{\"id\":\"...\"}}'::jsonb, 'products', true),\n  ('product_updated', 'Produto/Serviço Atualizado', 'Disparado quando um item é modificado', '{\"event_type\":\"product_updated\",\"product\":{\"id\":\"...\"}}'::jsonb, 'products', true),\n\n  -- WhatsApp (caso ainda não exista no Client)\n  ('whatsapp_message_received', 'Mensagem WhatsApp Recebida', 'Quando uma mensagem é recebida no WhatsApp', '{\"event_type\":\"whatsapp_message_received\",\"data\":{\"phone\":\"+5511999999999\"}}'::jsonb, 'whatsapp', true),\n  ('whatsapp_message_sent', 'Mensagem WhatsApp Enviada', 'Quando uma mensagem é enviada', '{\"event_type\":\"whatsapp_message_sent\",\"data\":{\"phone\":\"+5511999999999\"}}'::jsonb, 'whatsapp', true),\n  ('whatsapp_message_read', 'Mensagem WhatsApp Lida', 'Quando a mensagem é lida', '{\"event_type\":\"whatsapp_message_read\",\"data\":{\"message_id\":\"ABC\"}}'::jsonb, 'whatsapp', true),\n  ('whatsapp_presence', 'Presença WhatsApp', 'Mudança de presença (digitando, online)', '{\"event_type\":\"whatsapp_presence\",\"data\":{\"phone\":\"+5511999999999\",\"state\":\"composing\"}}'::jsonb, 'whatsapp', true),\n  ('whatsapp_contact_created', 'Contato WhatsApp Criado', 'Novo contato WhatsApp adicionado', '{\"event_type\":\"whatsapp_contact_created\",\"data\":{\"phone\":\"+5511999999999\"}}'::jsonb, 'whatsapp', true),\n  ('whatsapp_conversation_started', 'Conversa WhatsApp Iniciada', 'Nova conversa iniciada', '{\"event_type\":\"whatsapp_conversation_started\",\"data\":{\"phone\":\"+5511999999999\"}}'::jsonb, 'whatsapp', true)\non conflict (event_type) do update set\n  display_name = excluded.display_name,\n  description = excluded.description,\n  example_payload = excluded.example_payload,\n  category = excluded.category,\n  is_active = excluded.is_active;\n\n\n-- 5) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('19', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v020_crm_leads_stage_fk_and_interests",
      "name": "v20 - CRM Leads: stage FK + interests + value recalc",
      "checksum": "",
      "sql": "/*\n  CRM Leads.stage -> enforce consistency with CRM Stages\n  - Allow NULL on crm_leads.stage\n  - Backfill existing values to match crm_stages.name (case-insensitive)\n  - Null out unmatched values\n  - Add composite FK (organization_id, stage) -> crm_stages(organization_id, name)\n    with ON UPDATE CASCADE and ON DELETE SET NULL\n  - Remove legacy normalization trigger/functions that forced canonical values\n*/\n\nbegin;\n\n-- 1) Drop legacy trigger and functions (idempotent)\ndrop trigger if exists trg_crm_leads_normalize_stage on public.crm_leads;\ndrop function if exists public.trg_crm_leads_normalize_stage();\ndrop function if exists public.normalize_stage_name(uuid, text);\n\n-- 2) Allow NULL and drop default on crm_leads.stage\nalter table public.crm_leads\n  alter column stage drop default;\n\n-- stage might already be nullable, but drop not null just in case\nalter table public.crm_leads\n  alter column stage drop not null;\n\n-- 3) Backfill: normalize case to exact crm_stages.name when there is a match\nupdate public.crm_leads l\nset stage = s.name\nfrom public.crm_stages s\nwhere l.organization_id = s.organization_id\n  and s.name is not null\n  and l.stage is not null\n  and trim(l.stage) <> ''\n  and lower(l.stage) = lower(s.name);\n\n-- 4) Cleanup: set to NULL when not matching any stage name for the same org\nupdate public.crm_leads l\nset stage = null\nwhere l.stage is not null\n  and trim(l.stage) <> ''\n  and not exists (\n    select 1\n    from public.crm_stages s\n    where s.organization_id = l.organization_id\n      and s.name = l.stage\n  );\n\n-- Also null-out empty or 'null' textual values\nupdate public.crm_leads\nset stage = null\nwhere stage is null\n   or trim(coalesce(stage, '')) = ''\n   or lower(coalesce(stage, '')) = 'null';\n\n-- 5) Add helpful index for lookups by (organization_id, stage)\ncreate index if not exists idx_crm_leads_org_stage on public.crm_leads(organization_id, stage);\n\n-- 6) Add composite foreign key constraint\nalter table public.crm_leads\n  add constraint crm_leads_stage_fkey\n  foreign key (organization_id, stage)\n  references public.crm_stages(organization_id, name)\n  on update cascade\n  on delete set null;\n\ncommit;\n\n-- Add CNPJ and company_name to crm_leads\n-- Create crm_lead_interests to link leads with produtos_servicos and quantities\n\nbegin;\n\n-- Ensure pgcrypto for gen_random_uuid\ncreate extension if not exists pgcrypto;\n\n-- 1) New columns on crm_leads\nalter table public.crm_leads\n  add column if not exists cnpj text,\n  add column if not exists company_name text;\n\n-- 2) Interests table\ncreate table if not exists public.crm_lead_interests (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid not null,\n  lead_id uuid not null references public.crm_leads(id) on delete cascade,\n  produto_servico_id uuid not null references public.produtos_servicos(id) on delete restrict,\n  quantity integer not null default 1 check (quantity >= 1),\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  unique (lead_id, produto_servico_id)\n);\n\n-- 3) Indexes\ncreate index if not exists idx_crm_lead_interests_lead on public.crm_lead_interests(lead_id);\ncreate index if not exists idx_crm_lead_interests_prod on public.crm_lead_interests(produto_servico_id);\ncreate index if not exists idx_crm_lead_interests_org on public.crm_lead_interests(organization_id);\n\n-- 4) updated_at trigger\ncreate or replace function public.trg_set_timestamp() returns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\ndrop trigger if exists set_timestamp_crm_lead_interests on public.crm_lead_interests;\ncreate trigger set_timestamp_crm_lead_interests\n  before update on public.crm_lead_interests\n  for each row execute function public.trg_set_timestamp();\n\ncommit;\n\n-- Maintain crm_leads.value as sum of interested products (preco_base * quantity)\n-- If no interests, keep existing value (manual). We will only update value when interests change;\n-- if user set a manual value and there are interests, the trigger will compute and override.\n\nbegin;\n\ncreate or replace function public.recalc_lead_value(p_lead_id uuid) returns void as $$\ndeclare\n  v_org uuid;\n  v_sum numeric;\nbegin\n  select organization_id into v_org from public.crm_leads where id = p_lead_id;\n\n  -- Sum of preco_base * quantity for the same organization\n  select coalesce(sum(ps.preco_base * li.quantity), 0)\n    into v_sum\n  from public.crm_lead_interests li\n  join public.produtos_servicos ps\n    on ps.id = li.produto_servico_id\n   and ps.organization_id = li.organization_id\n  where li.lead_id = p_lead_id;\n\n  -- Update crm_leads.value if there are any interests\n  if v_sum > 0 then\n    update public.crm_leads\n       set value = v_sum,\n           updated_at = now()\n     where id = p_lead_id;\n  end if;\nend;\n$$ language plpgsql;\n\ncreate or replace function public.trg_recalc_lead_value() returns trigger as $$\nbegin\n  perform public.recalc_lead_value(coalesce(new.lead_id, old.lead_id));\n  return new;\nend;\n$$ language plpgsql;\n\ndo $$\nbegin\n  perform 1 from information_schema.tables\n   where table_schema = 'public' and table_name = 'crm_lead_interests';\n  if found then\n    drop trigger if exists recalc_lead_value_ins on public.crm_lead_interests;\n    create trigger recalc_lead_value_ins\n      after insert on public.crm_lead_interests\n      for each row execute function public.trg_recalc_lead_value();\n\n    drop trigger if exists recalc_lead_value_upd on public.crm_lead_interests;\n    create trigger recalc_lead_value_upd\n      after update on public.crm_lead_interests\n      for each row execute function public.trg_recalc_lead_value();\n\n    drop trigger if exists recalc_lead_value_del on public.crm_lead_interests;\n    create trigger recalc_lead_value_del\n      after delete on public.crm_lead_interests\n      for each row execute function public.trg_recalc_lead_value();\n  end if;\nend $$;\n\ncommit;\n\n\n\n\n-- 7) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('20', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v021_crm_leads_stage_case_insensitive",
      "name": "v21 - crm_leads.stage case-insensitive via trigger",
      "checksum": "",
      "sql": "/*\n  Case-insensitive support for crm_leads.stage against crm_stages.name\n  - Enforce uniqueness of (organization_id, lower(name)) in crm_stages\n  - BEFORE INSERT/UPDATE trigger on crm_leads to fix the stage casing\n    by replacing with the exact crm_stages.name for the org (if found)\n  - Does NOT relax FK semantics (FK stays), but makes inputs tolerant to case\n*/\n\nbegin;\n\n-- 1) Unique constraint (by functional unique index) to avoid duplicates by case\ncreate unique index if not exists crm_stages_org_lower_name_key\non public.crm_stages (organization_id, lower(name));\n\n-- 2) Function to fix the stage case before FK check\ncreate or replace function public.trg_crm_leads_fix_stage_case()\nreturns trigger\nlanguage plpgsql\nas $$\ndeclare\n  v_name text;\nbegin\n  -- Only when stage provided\n  if new.stage is not null and trim(new.stage) <> '' then\n    select s.name into v_name\n    from public.crm_stages s\n    where s.organization_id = new.organization_id\n      and lower(s.name) = lower(new.stage)\n    limit 1;\n\n    if v_name is not null then\n      new.stage := v_name; -- replace with exact cased name\n    end if;\n  end if;\n  return new;\nend;\n$$;\n\n-- 3) Install trigger (runs before FK validation)\ndrop trigger if exists trg_crm_leads_fix_stage_case on public.crm_leads;\ncreate trigger trg_crm_leads_fix_stage_case\nbefore insert or update on public.crm_leads\nfor each row execute function public.trg_crm_leads_fix_stage_case();\n\ncommit;\n\n\n-- 4) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('21', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v022_crm_leads_show_in_kanban",
      "name": "v22 - Kanban visibility: crm_leads.show_in_kanban",
      "checksum": "",
      "sql": "/*\n  Visibility control for Kanban: crm_leads.show_in_kanban\n  - Adds boolean column with default TRUE\n  - Backfills: converted leads => FALSE, others => TRUE\n  - BEFORE UPDATE trigger: when converted_client_id transitions from NULL to NOT NULL, set show_in_kanban=FALSE\n*/\n\nbegin;\n\n-- 1) Column\nalter table public.crm_leads\n  add column if not exists show_in_kanban boolean not null default true;\n\n-- 2) Backfill\nupdate public.crm_leads\nset show_in_kanban = case when converted_client_id is not null then false else true end;\n\n-- 3) Trigger to auto-hide on conversion (only on first transition)\ncreate or replace function public.trg_crm_leads_hide_on_conversion()\nreturns trigger\nlanguage plpgsql\nas $$\nbegin\n  if tg_op = 'UPDATE' then\n    if (old.converted_client_id is null and new.converted_client_id is not null) then\n      new.show_in_kanban := false;\n    end if;\n  end if;\n  return new;\nend;\n$$;\n\ndrop trigger if exists trg_crm_leads_hide_on_conversion on public.crm_leads;\ncreate trigger trg_crm_leads_hide_on_conversion\nbefore update on public.crm_leads\nfor each row execute function public.trg_crm_leads_hide_on_conversion();\n\ncommit;\n\n-- 4) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('22', now())\non conflict (version) do nothing;\n"
    }
    ,
    {
      "id": "v023_lead_sale_columns_entrada_link",
      "name": "v23 – Leads: sold_* e link de entradas",
      "checksum": "",
      "sql": "-- Add sale columns on crm_leads and link entradas to produto_servico when possible\n\nbegin;\n\n-- 1) Columns to store sold product and quantity (for AI agent/automation use)\nalter table public.crm_leads\n  add column if not exists sold_produto_servico_id uuid references public.produtos_servicos(id) on delete set null,\n  add column if not exists sold_quantity integer not null default 1 check (sold_quantity >= 1);\n\n-- 2) Update function to propagate produto_servico_id to entradas for lead payments\ncreate or replace function public.upsert_entrada_for_lead_payment(p_lead_id uuid)\nreturns void\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  r record;\n  v_entrada_id uuid;\n  v_product_id uuid;\nbegin\n  select * into r from public.crm_leads where id = p_lead_id;\n  if not found then\n    return;\n  end if;\n\n  if r.organization_id is null then\n    return;\n  end if;\n\n  -- Decide product to attach to entrada\n  v_product_id := r.sold_produto_servico_id;\n  if v_product_id is null then\n    select li.produto_servico_id\n      into v_product_id\n    from public.crm_lead_interests li\n    where li.lead_id = p_lead_id\n    order by li.created_at asc\n    limit 1;\n  end if;\n\n  if coalesce(r.has_payment, false) = true and coalesce(r.payment_value, 0) > 0 then\n    select entrada_id into v_entrada_id\n      from public.entradas_source_links\n     where organization_id = r.organization_id\n       and source_type = 'lead_payment'\n       and source_id = p_lead_id;\n\n    if v_entrada_id is null then\n      insert into public.entradas (\n        organization_id, descricao, valor, categoria, data_entrada,\n        metodo_pagamento, cliente_id, produto_servico_id, observacoes\n      ) values (\n        r.organization_id,\n        coalesce('Pagamento lead: ' || nullif(trim(r.name), ''), 'Pagamento lead'),\n        r.payment_value,\n        'Vendas',\n        now(),\n        'dinheiro',\n        null,\n        v_product_id,\n        'origem: lead_payment/' || p_lead_id::text\n      ) returning id into v_entrada_id;\n\n      insert into public.entradas_source_links (organization_id, source_type, source_id, entrada_id)\n      values (r.organization_id, 'lead_payment', p_lead_id, v_entrada_id);\n    else\n      update public.entradas\n         set descricao = coalesce('Pagamento lead: ' || nullif(trim(r.name), ''), 'Pagamento lead'),\n             valor = r.payment_value,\n             categoria = 'Vendas',\n             data_entrada = now(),\n             metodo_pagamento = 'dinheiro',\n             produto_servico_id = v_product_id\n       where id = v_entrada_id;\n    end if;\n  else\n    -- Remove entrada if payment no longer valid\n    select entrada_id into v_entrada_id\n      from public.entradas_source_links\n     where organization_id = r.organization_id\n       and source_type = 'lead_payment'\n       and source_id = p_lead_id;\n    if v_entrada_id is not null then\n      delete from public.entradas where id = v_entrada_id;\n    end if;\n  end if;\nend;\n$$;\n\ncommit;\n\n\n-- 3) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('23', now())\non conflict (version) do nothing;\n"
    }
    ,
    {
      "id": "v024_crm_stages_conversion_flag",
      "name": "v24 – crm_stages: is_conversion_stage flag",
      "checksum": "",
      "sql": "-- Add conversion flag to crm_stages so organizations can choose their conversion stage\n\nbegin;\n\nalter table public.crm_stages\n  add column if not exists is_conversion_stage boolean not null default false;\n\n-- Optional: ensure only one conversion stage per organization (soft, not strict):\n-- We won't add a partial unique index now to avoid migration conflicts; logic handled in app.\n\ncommit;\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('24', now())\non conflict (version) do nothing;\n"
    }
    ,
    {
      "id": "v025_fix_lead_conversion_and_fk",
      "name": "v25 – Fix lead conversion flow + FK ON DELETE SET NULL",
      "checksum": "",
      "sql": "-- Fix lead conversion flow and allow deleting clients referenced by converted leads\n-- Changes:\n-- 1) Recreate FK crm_leads.converted_client_id -> clients.id with ON DELETE SET NULL\n-- 2) Restore auto-convert trigger to actually mark converted_client_id\n-- 3) Backfill converted_client_id for existing data and realign show_in_kanban\n\nbegin;\n\n-- Increase timeout for heavy backfills on large datasets\nset local statement_timeout to '300s';\n\n-- Helpful indexes to speed up the backfill match (idempotent)\ncreate index if not exists clients_email_idx on public.clients(email);\ncreate index if not exists clients_telefone_idx on public.clients(telefone);\ncreate index if not exists crm_leads_email_idx on public.crm_leads(email);\ncreate index if not exists crm_leads_whatsapp_idx on public.crm_leads(whatsapp);\n\n-- 1) Recreate FK with ON DELETE SET NULL (previously NO ACTION)\nalter table if exists public.crm_leads\n  drop constraint if exists crm_leads_converted_client_id_fkey;\n\nalter table public.crm_leads\n  add constraint crm_leads_converted_client_id_fkey\n  foreign key (converted_client_id)\n  references public.clients(id)\n  on update cascade\n  on delete set null;\n\n-- 2) Restore auto-convert trigger to mark the lead as converted\ncreate or replace function public.trg_auto_convert_on_close()\nreturns trigger\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  if tg_op = 'UPDATE' then\n    if coalesce(old.stage, '') is distinct from coalesce(new.stage, '') then\n      if lower(coalesce(new.stage, '')) in ('fechado', 'fechado ganho', 'ganho', 'venda fechada') then\n        -- Avoid double work if already converted\n        if new.converted_client_id is null then\n          perform public.convert_lead_to_client(new.id);\n        end if;\n      end if;\n    end if;\n  end if;\n  return new;\nend;\n$$;\n\ndrop trigger if exists auto_convert_on_close on public.crm_leads;\ncreate trigger auto_convert_on_close\n  after update on public.crm_leads\n  for each row execute function public.trg_auto_convert_on_close();\n\n-- 3a) Backfill: set converted_client_id where we can match an existing client by phone/email in same org\nwith matches as (\n  select l.id as lead_id, c.id as client_id\n  from public.crm_leads l\n  join public.clients c\n    on c.organization_id = l.organization_id\n   and (\n     (l.whatsapp is not null and nullif(trim(l.whatsapp), '') is not null and c.telefone = trim(l.whatsapp))\n     or (l.email is not null and nullif(trim(l.email), '') is not null and c.email = trim(l.email))\n   )\n  where l.converted_client_id is null\n)\nupdate public.crm_leads l\nset converted_client_id = m.client_id,\n    converted_at = coalesce(l.converted_at, now())\nfrom matches m\nwhere l.id = m.lead_id;\n\n-- 3b) Realign show_in_kanban flag if the column exists\ndo $$\nbegin\n  if exists (\n    select 1\n    from information_schema.columns\n    where table_schema = 'public'\n      and table_name = 'crm_leads'\n      and column_name = 'show_in_kanban'\n  ) then\n    update public.crm_leads\n    set show_in_kanban = case when converted_client_id is not null then false else true end;\n  end if;\nend $$;\n\ncommit;\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('25', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v026_product_images_bucket_and_base64_column",
      "name": "v26 – Bucket de imagens e coluna imagens_base64",
      "checksum": "",
      "sql": "-- Cria bucket público para imagens de produtos e políticas básicas\n\nBEGIN;\n\n-- Bucket público para imagens de produtos\ninsert into storage.buckets (id, name, public)\nvalues ('product-images', 'product-images', true)\non conflict (id) do nothing;\n\n-- Leitura pública\ndrop policy if exists \"Public read access for product-images\" on storage.objects;\ncreate policy \"Public read access for product-images\"\n  on storage.objects\n  for select\n  using (bucket_id = 'product-images');\n\n-- Upload por usuários autenticados\ndrop policy if exists \"Authenticated upload to product-images\" on storage.objects;\ncreate policy \"Authenticated upload to product-images\"\n  on storage.objects\n  for insert to authenticated\n  with check (bucket_id = 'product-images');\n\n-- Atualização por usuários autenticados\ndrop policy if exists \"Authenticated update to product-images\" on storage.objects;\ncreate policy \"Authenticated update to product-images\"\n  on storage.objects\n  for update to authenticated\n  using (bucket_id = 'product-images')\n  with check (bucket_id = 'product-images');\n\n-- Exclusão por usuários autenticados\ndrop policy if exists \"Authenticated delete from product-images\" on storage.objects;\ncreate policy \"Authenticated delete from product-images\"\n  on storage.objects\n  for delete to authenticated\n  using (bucket_id = 'product-images');\n\nCOMMIT;\n\n-- Adiciona coluna para Base64 das imagens em produtos/serviços\n-- Armazena até 5 strings base64 separadas por quebras de linha (\"\\n\")\n\nBEGIN;\n\nALTER TABLE public.produtos_servicos\n  ADD COLUMN IF NOT EXISTS imagens_base64 text;\n\nCOMMENT ON COLUMN public.produtos_servicos.imagens_base64 IS 'Até 5 imagens em Base64 (data URL) separadas por quebra de linha (\\n).';\n\nCOMMIT;\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('26', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v027_dashboard_prefs_and_report_presets",
      "name": "v27 – Preferências de dashboard e presets de filtros",
      "checksum": "",
      "sql": "-- Preferências de dashboard e presets de filtros para Reports\n-- Observa: seguir convenção do projeto de criar migrações separadas do CLIENT-SQL-SETUP\n\ncreate table if not exists user_dashboard_prefs (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid not null,\n  user_id uuid not null,\n  page text not null,\n  tab text not null,\n  widgets jsonb not null,\n  created_at timestamptz default now(),\n  updated_at timestamptz default now()\n);\n\ncreate index if not exists idx_user_dashboard_prefs_org_user on user_dashboard_prefs(organization_id, user_id);\n\ncreate table if not exists report_filter_presets (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid not null,\n  user_id uuid not null,\n  name text not null,\n  filters jsonb not null,\n  created_at timestamptz default now()\n);\n\ncreate index if not exists idx_report_filter_presets_org_user on report_filter_presets(organization_id, user_id);\n\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('27', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v028_products_extensions_and_variants",
      "name": "v28 – Produtos: tags, custom_fields, variantes e relacionados",
      "checksum": "",
      "sql": "-- Extensões para Produtos/Serviços\n-- - tags (text[])\n-- - custom_fields (jsonb)\n-- - impostos/custos opcionais\n-- - status granular (rascunho, ativo, sob_demanda, fora_catalogo)\n-- - estoque_minimo e locais (jsonb)\n-- - tabelas auxiliares: produto_variantes e produtos_relacionados\n\nBEGIN;\n\n-- 1) Novas colunas na tabela principal\nALTER TABLE public.produtos_servicos\n  ADD COLUMN IF NOT EXISTS tags text[] DEFAULT '{}'::text[],\n  ADD COLUMN IF NOT EXISTS custom_fields jsonb DEFAULT '{}'::jsonb,\n  ADD COLUMN IF NOT EXISTS imposto_percent numeric(5,2) CHECK (imposto_percent >= 0 AND imposto_percent <= 100),\n  ADD COLUMN IF NOT EXISTS custo_base numeric(12,2),\n  ADD COLUMN IF NOT EXISTS status text DEFAULT 'ativo',\n  ADD COLUMN IF NOT EXISTS estoque_minimo integer DEFAULT 0,\n  ADD COLUMN IF NOT EXISTS estoque_locais jsonb DEFAULT '[]'::jsonb;\n\n-- Constraint de status\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint c\n    JOIN pg_class t ON c.conrelid = t.oid\n    WHERE t.relname = 'produtos_servicos' AND c.conname = 'produtos_servicos_status_check'\n  ) THEN\n    ALTER TABLE public.produtos_servicos\n      ADD CONSTRAINT produtos_servicos_status_check\n      CHECK (status = ANY (ARRAY['rascunho','ativo','sob_demanda','fora_catalogo']));\n  END IF;\nEND $$;\n\n-- Índices úteis\nCREATE INDEX IF NOT EXISTS idx_produtos_servicos_tags_gin ON public.produtos_servicos USING gin (tags);\nCREATE INDEX IF NOT EXISTS idx_produtos_servicos_status ON public.produtos_servicos (status);\n\n-- 2) Tabela de variantes/planos\nCREATE TABLE IF NOT EXISTS public.produto_variantes (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  organization_id uuid NOT NULL,\n  produto_id uuid NOT NULL REFERENCES public.produtos_servicos(id) ON DELETE CASCADE,\n  nome text NOT NULL,\n  preco numeric(12,2) NOT NULL DEFAULT 0,\n  cobranca_tipo text NOT NULL CHECK (cobranca_tipo = ANY (ARRAY['unica','mensal','trimestral','semestral','anual'])),\n  ativo boolean NOT NULL DEFAULT true,\n  created_at timestamptz NOT NULL DEFAULT now(),\n  updated_at timestamptz NOT NULL DEFAULT now()\n);\n\nCREATE INDEX IF NOT EXISTS idx_produto_variantes_produto ON public.produto_variantes (produto_id);\nCREATE INDEX IF NOT EXISTS idx_produto_variantes_org ON public.produto_variantes (organization_id);\n\n-- 3) Tabela de relacionamentos (upsell/cross-sell)\nCREATE TABLE IF NOT EXISTS public.produtos_relacionados (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  organization_id uuid NOT NULL,\n  produto_id uuid NOT NULL REFERENCES public.produtos_servicos(id) ON DELETE CASCADE,\n  relacionado_id uuid NOT NULL REFERENCES public.produtos_servicos(id) ON DELETE CASCADE,\n  created_at timestamptz NOT NULL DEFAULT now()\n);\n\n-- Evitar duplicidade\nCREATE UNIQUE INDEX IF NOT EXISTS uq_produtos_relacionados_pair\n  ON public.produtos_relacionados (produto_id, relacionado_id);\n\nCREATE INDEX IF NOT EXISTS idx_produtos_relacionados_org ON public.produtos_relacionados (organization_id);\n\nCOMMENT ON TABLE public.produto_variantes IS 'Planos/variações de um produto ou serviço.';\nCOMMENT ON TABLE public.produtos_relacionados IS 'Relacionamentos para upsell/cross-sell.';\n\nCOMMIT;\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('28', now())\non conflict (version) do nothing;"
    }
    ,
    {
      "id": "v029_crm_lead_interests_rls",
      "name": "v29 – crm_lead_interests: RLS por organização",
      "checksum": "",
      "sql": "-- Enable RLS and add organization-scoped policies for crm_lead_interests\n-- Safe, idempotent migration\n\nbegin;\n\n-- Ensure helper exists\ncreate or replace function public.set_rls_context(p_organization_id uuid)\nreturns void\nlanguage plpgsql\nas $$\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\nend; $$;\n\n-- Enable RLS on crm_lead_interests\ndo $$\nbegin\n  perform 1 from information_schema.tables \n   where table_schema = 'public' and table_name = 'crm_lead_interests';\n  if found then\n    execute 'alter table public.crm_lead_interests enable row level security';\n  end if;\nend $$;\n\n-- Policies (idempotent)\ndo $$\nbegin\n  if not exists (\n    select 1 from pg_policies \n    where schemaname = 'public' and tablename = 'crm_lead_interests' and policyname = 'interests_select_org'\n  ) then\n    create policy \"interests_select_org\"\n      on public.crm_lead_interests\n      for select\n      to authenticated, anon\n      using ((organization_id::text = nullif(current_setting('app.organization_id', true), '')));\n  end if;\n\n  if not exists (\n    select 1 from pg_policies \n    where schemaname = 'public' and tablename = 'crm_lead_interests' and policyname = 'interests_modify_org'\n  ) then\n    create policy \"interests_modify_org\"\n      on public.crm_lead_interests\n      for all\n      to authenticated, anon\n      using ((organization_id::text = nullif(current_setting('app.organization_id', true), '')))\n      with check ((organization_id::text = nullif(current_setting('app.organization_id', true), '')));\n  end if;\nend $$;\n\ncommit;\n\n\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('29', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v030_inline_interests_jsonb",
      "name": "v30 – Consolidar interesses em crm_leads.interests (JSONB)",
      "checksum": "",
      "sql": "-- Consolidate lead interests into crm_leads.interests (JSONB)\n-- Remove table crm_lead_interests and replace value recalculation and RPCs\n\nbegin;\n\n-- 1) Add interests column\nalter table if exists public.crm_leads\n  add column if not exists interests jsonb;\n\n-- 2) Backfill from crm_lead_interests if it exists\ndo $$\nbegin\n  if exists (\n    select 1 from information_schema.tables \n    where table_schema = 'public' and table_name = 'crm_lead_interests'\n  ) then\n    update public.crm_leads l\n       set interests = coalesce(\n         (\n           select jsonb_agg(jsonb_build_object(\n             'produto_servico_id', li.produto_servico_id,\n             'quantity', greatest(1, li.quantity)\n           ) order by li.created_at asc)\n           from public.crm_lead_interests li\n           where li.lead_id = l.id\n         ), '[]'::jsonb)\n     where l.interests is null;\n  end if;\nend $$;\n\n-- 3) Function to recalc lead value based on interests JSON\ncreate or replace function public.recalc_lead_value(p_lead_id uuid) returns void as $$\ndeclare\n  v_sum numeric;\n  v_org uuid;\n  v_interests jsonb;\nbegin\n  select organization_id, coalesce(interests, '[]'::jsonb)\n    into v_org, v_interests\n  from public.crm_leads\n  where id = p_lead_id;\n\n  if v_interests is null then\n    return;\n  end if;\n\n  select coalesce(sum(ps.preco_base * coalesce((item->>'quantity')::int, 1)), 0)\n    into v_sum\n  from jsonb_array_elements(v_interests) as item\n  join public.produtos_servicos ps\n    on ps.id = (item->>'produto_servico_id')::uuid\n   and ps.organization_id = v_org;\n\n  if v_sum > 0 then\n    update public.crm_leads\n       set value = v_sum,\n           updated_at = now()\n     where id = p_lead_id;\n  end if;\nend; $$ language plpgsql;\n\n-- 4) Trigger to recalc when interests change\ncreate or replace function public.trg_recalc_lead_value_on_leads() returns trigger as $$\nbegin\n  if tg_op in ('INSERT','UPDATE') then\n    perform public.recalc_lead_value(new.id);\n  end if;\n  return new;\nend; $$ language plpgsql;\n\n\ndrop trigger if exists recalc_lead_value_on_leads on public.crm_leads;\ncreate trigger recalc_lead_value_on_leads\n  after insert or update of interests on public.crm_leads\n  for each row execute function public.trg_recalc_lead_value_on_leads();\n\n-- 5) Update upsert_entrada_for_lead_payment to read first item from interests JSON\ncreate or replace function public.upsert_entrada_for_lead_payment(p_lead_id uuid)\nreturns void\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  r record;\n  v_entrada_id uuid;\n  v_product_id uuid;\n  v_first_item jsonb;\nbegin\n  select * into r from public.crm_leads where id = p_lead_id;\n  if not found then return; end if;\n  if r.organization_id is null then return; end if;\n\n  -- Preferred: explicit sold_produto_servico_id\n  v_product_id := r.sold_produto_servico_id;\n\n  -- Fallback: first interest item in JSON\n  if v_product_id is null and r.interests is not null then\n    select value into v_first_item from jsonb_array_elements(r.interests) limit 1;\n    if v_first_item is not null then\n      v_product_id := (v_first_item->>'produto_servico_id')::uuid;\n    end if;\n  end if;\n\n  if coalesce(r.has_payment, false) = true and coalesce(r.payment_value, 0) > 0 then\n    select entrada_id into v_entrada_id\n      from public.entradas_source_links\n     where organization_id = r.organization_id\n       and source_type = 'lead_payment'\n       and source_id = p_lead_id;\n\n    if v_entrada_id is null then\n      insert into public.entradas (\n        organization_id, descricao, valor, categoria, data_entrada,\n        metodo_pagamento, cliente_id, produto_servico_id, observacoes\n      ) values (\n        r.organization_id,\n        coalesce('Pagamento lead: ' || nullif(trim(r.name), ''), 'Pagamento lead'),\n        r.payment_value,\n        'Vendas',\n        now(),\n        'dinheiro',\n        null,\n        v_product_id,\n        'origem: lead_payment/' || p_lead_id::text\n      ) returning id into v_entrada_id;\n\n      insert into public.entradas_source_links (organization_id, source_type, source_id, entrada_id)\n      values (r.organization_id, 'lead_payment', p_lead_id, v_entrada_id);\n    else\n      update public.entradas\n         set descricao = coalesce('Pagamento lead: ' || nullif(trim(r.name), ''), 'Pagamento lead'),\n             valor = r.payment_value,\n             categoria = 'Vendas',\n             data_entrada = now(),\n             metodo_pagamento = 'dinheiro',\n             produto_servico_id = v_product_id\n       where id = v_entrada_id;\n    end if;\n  else\n    -- Remove entrada if payment no longer valid\n    select entrada_id into v_entrada_id\n      from public.entradas_source_links\n     where organization_id = r.organization_id\n       and source_type = 'lead_payment'\n       and source_id = p_lead_id;\n    if v_entrada_id is not null then\n      delete from public.entradas where id = v_entrada_id;\n    end if;\n  end if;\nend;\n$$;\n\n-- 6) Drop old triggers and table (idempotent)\ndo $$\nbegin\n  if exists (\n    select 1 from information_schema.tables where table_schema = 'public' and table_name = 'crm_lead_interests'\n  ) then\n    drop trigger if exists recalc_lead_value_ins on public.crm_lead_interests;\n    drop trigger if exists recalc_lead_value_upd on public.crm_lead_interests;\n    drop trigger if exists recalc_lead_value_del on public.crm_lead_interests;\n    drop table if exists public.crm_lead_interests cascade;\n  end if;\nend $$;\n\ncommit;\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('30', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v031_interest_columns_crm_leads",
      "name": "v31 – Interest columns em crm_leads + recálculo e pagamento",
      "checksum": "",
      "sql": "-- Add single interest columns on crm_leads and migrate from JSONB\n-- Creates: interest_produto_servico_id (uuid), interest_quantity (int4)\n-- Backfills from crm_leads.interests (first item) if present\n-- Updates value recalculation and payment upsert fallback to use the new columns\n\nbegin;\n\n-- 1) Add new columns (idempotent)\nalter table if exists public.crm_leads\n  add column if not exists interest_produto_servico_id uuid,\n  add column if not exists interest_quantity int4;\n\n-- Default interest_quantity to 1 when NULL\nupdate public.crm_leads\n   set interest_quantity = 1\n where interest_quantity is null;\n\n-- 2) Backfill from interests JSONB (first array item)\ndo $$\ndeclare\n  v_has_interests boolean;\nbegin\n  select exists (\n    select 1 from information_schema.columns \n     where table_schema='public' and table_name='crm_leads' and column_name='interests'\n  ) into v_has_interests;\n\n  if v_has_interests then\n    update public.crm_leads l\n       set interest_produto_servico_id = coalesce(interest_produto_servico_id,\n         (\n           select (elem->>'produto_servico_id')::uuid\n             from jsonb_array_elements(l.interests) elem\n             order by 1\n             limit 1\n         )\n       ),\n           interest_quantity = coalesce(interest_quantity,\n         (\n           select greatest(1, coalesce((elem->>'quantity')::int, 1))\n             from jsonb_array_elements(l.interests) elem\n             order by 1\n             limit 1\n         )\n       )\n     where l.interests is not null and jsonb_typeof(l.interests) = 'array';\n  end if;\nend $$;\n\n-- 3) Recalc value based on interest_* columns\ncreate or replace function public.recalc_lead_value_by_interest(p_lead_id uuid) returns void as $$\ndeclare\n  r record;\n  v_price numeric;\n  v_total numeric;\nbegin\n  select organization_id, interest_produto_servico_id, greatest(1, coalesce(interest_quantity, 1)) as qty\n    into r\n  from public.crm_leads\n  where id = p_lead_id;\n\n  if r.interest_produto_servico_id is null then\n    return;\n  end if;\n\n  select ps.preco_base into v_price\n    from public.produtos_servicos ps\n   where ps.id = r.interest_produto_servico_id\n     and ps.organization_id = r.organization_id;\n\n  v_total := coalesce(v_price, 0) * coalesce(r.qty, 1);\n\n  update public.crm_leads\n     set value = coalesce(v_total, 0),\n         updated_at = now()\n   where id = p_lead_id;\nend;\n$$ language plpgsql;\n\n-- 4) Trigger to recalc when interest columns change\ncreate or replace function public.trg_recalc_lead_value_on_interest() returns trigger as $$\nbegin\n  if tg_op in ('INSERT','UPDATE') then\n    perform public.recalc_lead_value_by_interest(new.id);\n  end if;\n  return new;\nend; $$ language plpgsql;\n\n\ndrop trigger if exists recalc_lead_value_on_interest on public.crm_leads;\ncreate trigger recalc_lead_value_on_interest\n  after insert or update of interest_produto_servico_id, interest_quantity on public.crm_leads\n  for each row execute function public.trg_recalc_lead_value_on_interest();\n\n-- 5) Update payment upsert function to use interest_* as fallback\ncreate or replace function public.upsert_entrada_for_lead_payment(p_lead_id uuid)\nreturns void\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  r record;\n  v_entrada_id uuid;\n  v_product_id uuid;\nbegin\n  select * into r from public.crm_leads where id = p_lead_id;\n  if not found then return; end if;\n  if r.organization_id is null then return; end if;\n\n  -- Preferred: explicit sold product\n  v_product_id := r.sold_produto_servico_id;\n\n  -- Fallback: interest product\n  if v_product_id is null then\n    v_product_id := r.interest_produto_servico_id;\n  end if;\n\n  if coalesce(r.has_payment, false) = true and coalesce(r.payment_value, 0) > 0 then\n    select entrada_id into v_entrada_id\n      from public.entradas_source_links\n     where organization_id = r.organization_id\n       and source_type = 'lead_payment'\n       and source_id = p_lead_id;\n\n    if v_entrada_id is null then\n      insert into public.entradas (\n        organization_id, descricao, valor, categoria, data_entrada,\n        metodo_pagamento, cliente_id, produto_servico_id, observacoes\n      ) values (\n        r.organization_id,\n        coalesce('Pagamento lead: ' || nullif(trim(r.name), ''), 'Pagamento lead'),\n        r.payment_value,\n        'Vendas',\n        now(),\n        'dinheiro',\n        null,\n        v_product_id,\n        'origem: lead_payment/' || p_lead_id::text\n      ) returning id into v_entrada_id;\n\n      insert into public.entradas_source_links (organization_id, source_type, source_id, entrada_id)\n      values (r.organization_id, 'lead_payment', p_lead_id, v_entrada_id);\n    else\n      update public.entradas\n         set descricao = coalesce('Pagamento lead: ' || nullif(trim(r.name), ''), 'Pagamento lead'),\n             valor = r.payment_value,\n             categoria = 'Vendas',\n             data_entrada = now(),\n             metodo_pagamento = 'dinheiro',\n             produto_servico_id = v_product_id\n       where id = v_entrada_id;\n    end if;\n  else\n    -- Remove if no longer valid\n    select entrada_id into v_entrada_id\n      from public.entradas_source_links\n     where organization_id = r.organization_id\n       and source_type = 'lead_payment'\n       and source_id = p_lead_id;\n    if v_entrada_id is not null then\n      delete from public.entradas where id = v_entrada_id;\n    end if;\n  end if;\nend;\n$$;\n\ncommit;\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('31', now())\non conflict (version) do nothing;\n"
    }
    ,
    {
      "id": "v032_sold_quantity_conditional",
      "name": "v32 – crm_leads: sold_quantity opcional e CHECK condicional",
      "checksum": "",
      "sql": "begin;\n\n-- Remover NOT NULL e default\nalter table if exists public.crm_leads\n  alter column sold_quantity drop not null;\n\n-- Dropar default se existir\ndo $$\nbegin\n  begin\n    alter table public.crm_leads alter column sold_quantity drop default;\n  exception when others then null;\nend;\n$$;\n\n-- Adicionar CHECK condicional (idempotente)\ndo $$\nbegin\n  if not exists (\n    select 1 from pg_constraint c\n    join pg_class t on c.conrelid = t.oid\n   where t.relname = 'crm_leads' and c.conname = 'crm_leads_sold_qty_req_when_product'\n  ) then\n    alter table public.crm_leads\n      add constraint crm_leads_sold_qty_req_when_product\n      check (sold_produto_servico_id is null or (sold_quantity is not null and sold_quantity >= 1));\n  end if;\nend $$;\n\ncommit;\n\n-- Marcar versão\ninsert into public.app_migrations (version, applied_at) values ('32', now()) on conflict (version) do nothing;"
    }
    ,
    {
      "id": "v033_lead_activity_origin",
      "name": "v33 – crm_lead_activities: origin tagging",
      "checksum": "",
      "sql": "--\n-- Add origin tagging for CRM lead activities\n-- Distinção entre ações feitas via UI (com header) e automações (sem header)\n--\n\n-- 1) Schema: adicionar coluna de origem\nalter table if exists public.crm_lead_activities\n  add column if not exists origin text;\n\ncomment on column public.crm_lead_activities.origin is 'Origem do evento: ui | automation | edge | system';\n\n-- 2) Função utilitária segura para obter header da requisição (se disponível)\ncreate or replace function public.get_request_header(p_name text)\nreturns text\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  v_headers text;\n  v_value text;\nbegin\n  -- Tenta ler os headers do PostgREST (se disponível na versão do Supabase)\n  begin\n    v_headers := current_setting('request.headers', true);\n  exception when others then\n    v_headers := null;\n  end;\n\n  if v_headers is null then\n    return null;\n  end if;\n\n  begin\n    v_value := (v_headers::jsonb ->> p_name);\n  exception when others then\n    v_value := null;\n  end;\n\n  return v_value;\nend;\n$$;\n\n-- 3) Atualizar trigger para registrar a origem\ncreate or replace function public.log_crm_lead_changes()\nreturns trigger\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  v_actor uuid;\n  v_any_inserted boolean := false;\n  v_origin text;\nbegin\n  v_actor := coalesce(new.updated_by, new.created_by, old.updated_by, old.created_by);\n  v_origin := coalesce(public.get_request_header('x-tomik-origin'), 'automation');\n\n  if tg_op = 'INSERT' then\n    insert into public.crm_lead_activities (\n      lead_id, user_id, action, field_changed, description, origin, created_at\n    ) values (\n      new.id, v_actor, 'INSERT', 'insert', 'Lead criado: ' || coalesce(new.name,''), v_origin, now()\n    );\n    return new;\n\n  elsif tg_op = 'UPDATE' then\n    -- Stage change\n    if old.stage is distinct from new.stage then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, origin, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'stage',\n        'Lead movido para: ' || coalesce(new.stage,'indefinido'),\n        old.stage, new.stage, v_origin, now()\n      );\n      v_any_inserted := true;\n    end if;\n\n    -- Description change\n    if coalesce(old.description,'') is distinct from coalesce(new.description,'') then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, origin, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'description',\n        'Descrição atualizada',\n        old.description, new.description, v_origin, now()\n      );\n      v_any_inserted := true;\n    end if;\n\n    -- Payment status change\n    if coalesce(old.has_payment,false) is distinct from coalesce(new.has_payment,false) then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, origin, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'has_payment',\n        case when new.has_payment then 'Lead marcado como pago' else 'Lead desmarcado como pago' end,\n        coalesce(old.payment_value,0)::text,\n        coalesce(new.payment_value,0)::text,\n        v_origin, now()\n      );\n      v_any_inserted := true;\n    elsif coalesce(old.payment_value,0) is distinct from coalesce(new.payment_value,0) then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, old_value, new_value, origin, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', 'payment_value',\n        'Valor do pagamento atualizado',\n        coalesce(old.payment_value,0)::text,\n        coalesce(new.payment_value,0)::text,\n        v_origin, now()\n      );\n      v_any_inserted := true;\n    end if;\n\n    if not v_any_inserted then\n      insert into public.crm_lead_activities (\n        lead_id, user_id, action, field_changed, description, origin, created_at\n      ) values (\n        new.id, v_actor, 'UPDATE', null, 'Lead atualizado: ' || coalesce(new.name,''), v_origin, now()\n      );\n    end if;\n\n    return new;\n\n  elsif tg_op = 'DELETE' then\n    insert into public.crm_lead_activities (\n      lead_id, user_id, action, field_changed, description, origin, created_at\n    ) values (\n      old.id, v_actor, 'DELETE', 'delete', 'Lead excluído: ' || coalesce(old.name,''), v_origin, now()\n    );\n    return old;\n  end if;\n\n  return new;\nexception when others then\n  raise notice 'CRM lead activity logging failed: %', sqlerrm;\n  if tg_op = 'DELETE' then\n    return old;\n  else\n    return new;\n  end if;\nend;\n$$;\n\n-- 4) Garantir trigger\ndrop trigger if exists crm_lead_activity_trigger on public.crm_leads;\ncreate trigger crm_lead_activity_trigger\n  after insert or update or delete on public.crm_leads\n  for each row execute function public.log_crm_lead_changes();\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('33', now())\non conflict (version) do nothing;"
    }
    ,
    {
      "id": "v034_products_sku_and_variants",
      "name": "v34 – Produtos: SKU em produtos e tabela de variantes",
      "checksum": "",
      "sql": "/*\n  # Add SKU to produtos_servicos and create produto_variantes table\n\n  1. Add column:\n     - produtos_servicos.sku text (nullable)\n     - Unique index (organization_id, sku) where sku is not null\n\n  2. Create table produto_variantes (if not exists)\n     - id uuid PK\n     - organization_id uuid\n     - produto_id uuid FK -> produtos_servicos(id) on delete cascade\n     - nome text not null\n     - preco numeric(12,2) not null default 0\n     - cobranca_tipo text check in ('unica','mensal','trimestral','semestral','anual') default 'unica'\n     - ativo boolean default true\n     - created_at timestamptz default now()\n     - updated_at timestamptz default now()\n\n  3. Security\n     - Enable RLS\n     - Dev policy permissiva (mantém padrão do projeto)\n\n  4. Indexes\n     - produto_variantes: organization_id, produto_id\n*/\n\n-- 1) SKU column\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM information_schema.columns \n    WHERE table_schema = 'public' AND table_name = 'produtos_servicos' AND column_name = 'sku'\n  ) THEN\n    ALTER TABLE public.produtos_servicos ADD COLUMN sku text;\n  END IF;\nEND $$;\n\n-- Unique index for (organization_id, sku) when sku is not null\nCREATE UNIQUE INDEX IF NOT EXISTS produtos_servicos_org_sku_uniq\n  ON public.produtos_servicos(organization_id, sku)\n  WHERE sku IS NOT NULL;\n\n-- 2) produto_variantes table\nCREATE TABLE IF NOT EXISTS public.produto_variantes (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  organization_id uuid NOT NULL,\n  produto_id uuid NOT NULL REFERENCES public.produtos_servicos(id) ON DELETE CASCADE,\n  nome text NOT NULL,\n  preco numeric(12,2) NOT NULL DEFAULT 0,\n  cobranca_tipo text NOT NULL DEFAULT 'unica'::text CHECK (cobranca_tipo = ANY (ARRAY['unica'::text,'mensal'::text,'trimestral'::text,'semestral'::text,'anual'::text])),\n  ativo boolean DEFAULT true,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now()\n);\n\nALTER TABLE public.produto_variantes ENABLE ROW LEVEL SECURITY;\n\n-- Dev permissive policy (align with project defaults)\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'produto_variantes' AND policyname = 'Dev: acesso total produto_variantes'\n  ) THEN\n    CREATE POLICY \"Dev: acesso total produto_variantes\" ON public.produto_variantes FOR ALL TO public USING (true) WITH CHECK (true);\n  END IF;\nEND $$;\n\n-- Indexes\nCREATE INDEX IF NOT EXISTS produto_variantes_org_idx ON public.produto_variantes(organization_id);\nCREATE INDEX IF NOT EXISTS produto_variantes_produto_idx ON public.produto_variantes(produto_id);\n\n\n\n\n-- 1) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('34', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v035_crm_leads_custom_fields",
      "name": "v35 – CRM Leads: custom_fields e índices de apoio à migração",
      "checksum": "",
      "sql": "-- v35 – CRM Leads: custom_fields e índices de apoio à migração\n\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM information_schema.columns \n    WHERE table_schema = 'public' AND table_name = 'crm_leads' AND column_name = 'custom_fields'\n  ) THEN\n    ALTER TABLE public.crm_leads ADD COLUMN custom_fields jsonb DEFAULT '{}'::jsonb;\n  END IF;\nEND $$;\n\nCREATE INDEX IF NOT EXISTS crm_leads_org_whatsapp_idx ON public.crm_leads(organization_id, whatsapp);\nCREATE INDEX IF NOT EXISTS crm_leads_org_email_idx ON public.crm_leads(organization_id, email);\n\nINSERT INTO public.app_migrations (version, applied_at)\nVALUES ('35', now())\nON CONFLICT (version) DO NOTHING;\n"
    },
    {
      "id": "v036_rag_pgvector_embeddings",
      "name": "v36 – RAG datasets e embeddings (pgvector)",
      "checksum": "",
      "sql": "-- v36 – RAG datasets e embeddings (pgvector)\n\n-- 0) Extensão pgvector (idempotente)\ncreate extension if not exists vector;\n\n-- 1) Função utilitária para setar organization_id a partir do contexto\ncreate or replace function public.rag_set_org_from_context()\nreturns trigger\nlanguage plpgsql\nas $$\nbegin\n  if new.organization_id is null then\n    begin\n      new.organization_id := nullif(current_setting('app.organization_id', true), '')::uuid;\n    exception when others then\n      new.organization_id := new.organization_id;\n    end;\n  end if;\n  return new;\nend;\n$$;\n\n-- 2) Tabela de fontes (um dataset por upload)\ncreate table if not exists public.rag_sources (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid,\n  name text not null,\n  storage_path text not null,\n  mime_type text,\n  status text not null default 'pending', -- pending|processing|ready|failed\n  total_rows integer default 0,\n  processed_rows integer default 0,\n  schema_json jsonb,\n  created_by uuid,\n  error text,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now()\n);\n\n-- Trigger para preencher organization_id\ndrop trigger if exists trg_rag_sources_set_org_from_context on public.rag_sources;\ncreate trigger trg_rag_sources_set_org_from_context\nbefore insert on public.rag_sources\nfor each row execute function public.rag_set_org_from_context();\n\n-- 3) Itens/chunks (texto + embedding)\ncreate table if not exists public.rag_items (\n  id bigserial primary key,\n  organization_id uuid,\n  source_id uuid not null references public.rag_sources(id) on delete cascade,\n  row_index integer,\n  category text,\n  content text not null,\n  fields jsonb,\n  metadata jsonb,\n  hash text unique,\n  embedding vector(1536),\n  created_at timestamptz not null default now()\n);\n\n-- Trigger para preencher organization_id nos itens\ndrop trigger if exists trg_rag_items_set_org_from_context on public.rag_items;\ncreate trigger trg_rag_items_set_org_from_context\nbefore insert on public.rag_items\nfor each row execute function public.rag_set_org_from_context();\n\n-- 4) Índices úteis\ncreate index if not exists rag_sources_org_idx on public.rag_sources (organization_id);\ncreate index if not exists rag_items_org_idx on public.rag_items (organization_id);\ncreate index if not exists rag_items_source_idx on public.rag_items (source_id);\ncreate index if not exists rag_items_category_idx on public.rag_items (category);\ncreate index if not exists rag_items_embedding_ivfflat on public.rag_items using ivfflat (embedding vector_cosine_ops) with (lists = 100);\n\n-- 5) RLS por organização\nalter table public.rag_sources enable row level security;\nalter table public.rag_items enable row level security;\n\ndo $$ begin\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='rag_sources' and policyname='rag_sources_select_by_org'\n  ) then\n    create policy rag_sources_select_by_org on public.rag_sources\n      for select to authenticated\n      using (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\n\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='rag_sources' and policyname='rag_sources_insert_by_org'\n  ) then\n    create policy rag_sources_insert_by_org on public.rag_sources\n      for insert to authenticated\n      with check (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\n\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='rag_sources' and policyname='rag_sources_update_by_org'\n  ) then\n    create policy rag_sources_update_by_org on public.rag_sources\n      for update to authenticated\n      using (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      ) with check (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\nend $$;\n\n\ndo $$ begin\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='rag_items' and policyname='rag_items_select_by_org'\n  ) then\n    create policy rag_items_select_by_org on public.rag_items\n      for select to authenticated\n      using (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\n\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='rag_items' and policyname='rag_items_insert_by_org'\n  ) then\n    create policy rag_items_insert_by_org on public.rag_items\n      for insert to authenticated\n      with check (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\n\n  if not exists (\n    select 1 from pg_policies where schemaname='public' and tablename='rag_items' and policyname='rag_items_update_by_org'\n  ) then\n    create policy rag_items_update_by_org on public.rag_items\n      for update to authenticated\n      using (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      ) with check (\n        organization_id is not null and organization_id::text = current_setting('app.organization_id', true)\n      );\n  end if;\nend $$;\n\n-- 6) RPC de similaridade (usa organization_id do contexto por padrão)\ndrop function if exists public.match_rag(vector, uuid, text, int, uuid);\ncreate or replace function public.match_rag(\n  p_query_embedding vector(1536),\n  p_source_id uuid default null,\n  p_category text default null,\n  p_limit int default 10,\n  p_org uuid default null\n:)\nreturns table (\n  id bigint,\n  source_id uuid,\n  category text,\n  content text,\n  fields jsonb,\n  metadata jsonb,\n  similarity float\n)\nlanguage sql\nstable\nas $$\n  select\n    ri.id,\n    ri.source_id,\n    ri.category,\n    ri.content,\n    ri.fields,\n    ri.metadata,\n    1 - (ri.embedding <=> p_query_embedding) as similarity\n  from public.rag_items ri\n  where ri.embedding is not null\n    and (\n      ri.organization_id = coalesce(p_org, nullif(current_setting('app.organization_id', true), '')::uuid)\n    )\n    and (p_source_id is null or ri.source_id = p_source_id)\n    and (p_category is null or ri.category = p_category)\n  order by ri.embedding <=> p_query_embedding\n  limit greatest(1, p_limit);\n$$;\n\n-- 7) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('36', now())\non conflict (version) do nothing;\n\n-- Comentários\ncomment on table public.rag_sources is 'Datasets enviados pelo usuário (CSV/XLSX/TXT) para RAG';\ncomment on table public.rag_items is 'Linhas/chunks normalizados com embedding para busca semântica';\ncomment on function public.match_rag is 'Busca por similaridade (cosine) em rag_items com filtros opcionais';"
    },
    {
      "id": "v037_produtos_servicos_checkout_url",
      "name": "v37 – Produtos: checkout_url em produtos_servicos",
      "checksum": "",
      "sql": "BEGIN;\n\nLOCK TABLE public.produtos_servicos IN SHARE ROW EXCLUSIVE MODE;\n\n-- Add checkout_url column for product/checkout link\nALTER TABLE public.produtos_servicos\n  ADD COLUMN IF NOT EXISTS checkout_url text;\n\nCOMMENT ON COLUMN public.produtos_servicos.checkout_url IS 'Public product/checkout link (optional)';\n\n-- Optional: basic URL sanity via length; no strict constraint to avoid breaking imports\n-- ALTER TABLE public.produtos_servicos\n--   ADD CONSTRAINT produtos_servicos_checkout_url_len CHECK (char_length(checkout_url) <= 2048) NOT VALID;\n\nCOMMIT;\n\n-- 7) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('37', now())\non conflict (version) do nothing;"
    },
    {
      "id": "v038_produtos_servicos_sales_page_url",
      "name": "v38 – Produtos: sales_page_url em produtos_servicos",
      "checksum": "",
      "sql": "BEGIN;\n\nLOCK TABLE public.produtos_servicos IN SHARE ROW EXCLUSIVE MODE;\n\n-- Add sales_page_url column for product sales/landing page\nALTER TABLE public.produtos_servicos\n  ADD COLUMN IF NOT EXISTS sales_page_url text;\n\nCOMMENT ON COLUMN public.produtos_servicos.sales_page_url IS 'Public sales/landing page link (optional)';\n\n-- Optional: basic URL sanity via length; no strict constraint to avoid breaking imports\n-- ALTER TABLE public.produtos_servicos\n--   ADD CONSTRAINT produtos_servicos_sales_page_url_len CHECK (char_length(sales_page_url) <= 2048) NOT VALID;\n\nCOMMIT;\n\n-- 8) Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('38', now())\non conflict (version) do nothing;"
    }
    ,
    {
      "id": "v039_products_variants_custom_fields",
      "name": "v39 – Produtos: variantes com checkout_url e custom_fields garantidos",
      "checksum": "",
      "sql": "-- v39 – Produtos: garantir custom_fields/tags e adicionar checkout_url em produto_variantes\n\nBEGIN;\n\nALTER TABLE public.produtos_servicos\n  ADD COLUMN IF NOT EXISTS tags text[] DEFAULT '{}'::text[],\n  ADD COLUMN IF NOT EXISTS custom_fields jsonb DEFAULT '{}'::jsonb,\n  ADD COLUMN IF NOT EXISTS imposto_percent numeric(5,2) CHECK (imposto_percent >= 0 AND imposto_percent <= 100),\n  ADD COLUMN IF NOT EXISTS custo_base numeric(12,2),\n  ADD COLUMN IF NOT EXISTS status text DEFAULT 'ativo',\n  ADD COLUMN IF NOT EXISTS estoque_minimo integer DEFAULT 0,\n  ADD COLUMN IF NOT EXISTS estoque_locais jsonb DEFAULT '[]'::jsonb;\n\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint c JOIN pg_class t ON c.conrelid = t.oid\n    WHERE t.relname = 'produtos_servicos' AND c.conname = 'produtos_servicos_status_check'\n  ) THEN\n    ALTER TABLE public.produtos_servicos\n      ADD CONSTRAINT produtos_servicos_status_check\n      CHECK (status = ANY (ARRAY['rascunho','ativo','sob_demanda','fora_catalogo']));\n  END IF;\nEND $$;\n\nCREATE INDEX IF NOT EXISTS idx_produtos_servicos_tags_gin ON public.produtos_servicos USING gin (tags);\nCREATE INDEX IF NOT EXISTS idx_produtos_servicos_status ON public.produtos_servicos (status);\n\nCREATE TABLE IF NOT EXISTS public.produto_variantes (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  organization_id uuid NOT NULL,\n  produto_id uuid NOT NULL REFERENCES public.produtos_servicos(id) ON DELETE CASCADE,\n  nome text NOT NULL,\n  preco numeric(12,2) NOT NULL DEFAULT 0,\n  cobranca_tipo text NOT NULL CHECK (cobranca_tipo = ANY (ARRAY['unica','mensal','trimestral','semestral','anual'])),\n  ativo boolean NOT NULL DEFAULT true,\n  created_at timestamptz NOT NULL DEFAULT now(),\n  updated_at timestamptz NOT NULL DEFAULT now()\n);\n\nALTER TABLE public.produto_variantes\n  ADD COLUMN IF NOT EXISTS checkout_url text;\n\nCREATE INDEX IF NOT EXISTS idx_produto_variantes_produto ON public.produto_variantes (produto_id);\nCREATE INDEX IF NOT EXISTS idx_produto_variantes_org ON public.produto_variantes (organization_id);\n\nALTER TABLE public.produto_variantes ENABLE ROW LEVEL SECURITY;\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'produto_variantes' AND policyname = 'Dev: acesso total produto_variantes'\n  ) THEN\n    CREATE POLICY \"Dev: acesso total produto_variantes\" ON public.produto_variantes FOR ALL TO public USING (true) WITH CHECK (true);\n  END IF;\nEND $$;\n\nCOMMIT;\n\ninsert into public.app_migrations (version, applied_at) values ('39', now()) on conflict (version) do nothing;"
    }
    ,
    {
      "id": "v040_qna_pairs",
      "name": "v40 – Q&A: tabela qna_pairs por organização + RLS",
      "checksum": "",
      "sql": "-- Q&A Pairs per organization\nset search_path = public, auth;\n\ncreate table if not exists public.qna_pairs (\n  id uuid primary key default gen_random_uuid(),\n  organization_id uuid not null,\n  pergunta text not null,\n  resposta text not null,\n  categoria text default 'Geral',\n  tags text[] default '{}',\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now()\n);\n\ncreate index if not exists idx_qna_pairs_org on public.qna_pairs(organization_id);\ncreate index if not exists idx_qna_pairs_categoria on public.qna_pairs(categoria);\ncreate index if not exists idx_qna_pairs_search on public.qna_pairs using gin (to_tsvector('portuguese', coalesce(pergunta,'') || ' ' || coalesce(resposta,'') || ' ' || coalesce(categoria,'')));\n\nalter table public.qna_pairs enable row level security;\n\n-- updated_at trigger (reusable)\ncreate or replace function public.set_updated_at()\nreturns trigger as $$\nbegin\n  new.updated_at = now();\n  return new;\nend;\n$$ language plpgsql;\n\ndrop trigger if exists set_timestamp_on_qna_pairs on public.qna_pairs;\ncreate trigger set_timestamp_on_qna_pairs\nbefore update on public.qna_pairs\nfor each row execute function public.set_updated_at();\n\n-- RLS: organization scoped via app.organization_id (set by set_rls_context)\ndo $$\nbegin\n  if not exists (select 1 from pg_policies where schemaname='public' and tablename='qna_pairs' and policyname='qna_pairs_select_own_org') then\n    create policy qna_pairs_select_own_org on public.qna_pairs\n      for select to authenticated\n      using (\n        organization_id is not null\n        and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n      );\n  end if;\n\n  if not exists (select 1 from pg_policies where schemaname='public' and tablename='qna_pairs' and policyname='qna_pairs_modify_own_org') then\n    create policy qna_pairs_modify_own_org on public.qna_pairs\n      for all to authenticated\n      using (\n        organization_id is not null\n        and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n      )\n      with check (\n        organization_id is not null\n        and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n      );\n  end if;\nend $$;\n\ncomment on table public.qna_pairs is 'Perguntas e Respostas por organização (Q&A Knowledge Base).';\n\n\n\n-- 3) Marcar versão\nINSERT INTO public.app_migrations (version, applied_at)\nVALUES ('40', now())\nON CONFLICT (version) DO NOTHING;"
    },
    {
      "id": "v041_qna_pairs_rls_fix",
      "name": "v41 – Q&A: ajustar RLS para SELECT por anon (org context)",
      "checksum": "",
      "sql": "-- v41 – Q&A: ajustar RLS para permitir SELECT por anon (com contexto de organização)\n\nBEGIN;\n\n-- Garantir que RLS está habilitado\nALTER TABLE public.qna_pairs ENABLE ROW LEVEL SECURITY;\n\n-- Recriar política de SELECT para incluir anon (idempotente)\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1 FROM pg_policies \n    WHERE schemaname='public' AND tablename='qna_pairs' AND policyname='qna_pairs_select_own_org'\n  ) THEN\n    DROP POLICY qna_pairs_select_own_org ON public.qna_pairs;\n  END IF;\nEND $$;\n\nCREATE POLICY qna_pairs_select_own_org ON public.qna_pairs\n  FOR SELECT\n  TO anon, authenticated\n  USING (\n    organization_id IS NOT NULL\n    AND organization_id::text = NULLIF(current_setting('app.organization_id', true), '')\n  );\n\n-- Garantir que a política de modificação existe (apenas autenticados)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_policies \n    WHERE schemaname='public' AND tablename='qna_pairs' AND policyname='qna_pairs_modify_own_org'\n  ) THEN\n    CREATE POLICY qna_pairs_modify_own_org ON public.qna_pairs\n      FOR ALL\n      TO authenticated\n      USING (\n        organization_id IS NOT NULL\n        AND organization_id::text = NULLIF(current_setting('app.organization_id', true), '')\n      )\n      WITH CHECK (\n        organization_id IS NOT NULL\n        AND organization_id::text = NULLIF(current_setting('app.organization_id', true), '')\n      );\n  END IF;\nEND $$;\n\nCOMMIT;\n\n-- Marcar versão\nINSERT INTO public.app_migrations (version, applied_at)\nVALUES ('41', now())\nON CONFLICT (version) DO NOTHING;"
    },
    {
      "id": "v042_qna_pairs_anon_modify",
      "name": "v42 – Q&A: permitir INSERT/UPDATE/DELETE via anon (escopo por organização)",
      "checksum": "",
      "sql": "-- v42 – Q&A: permitir INSERT/UPDATE/DELETE via anon (escopo por organização)\n\nset search_path = public, auth;\n\nalter table public.qna_pairs enable row level security;\n\ndo $$\nbegin\n  if exists (\n    select 1 from pg_policies \n    where schemaname='public' and tablename='qna_pairs' and policyname='qna_pairs_modify_own_org'\n  ) then\n    drop policy qna_pairs_modify_own_org on public.qna_pairs;\n  end if;\nend $$;\n\ncreate policy qna_pairs_modify_own_org on public.qna_pairs\n  for all\n  to anon, authenticated\n  using (\n    organization_id is not null\n    and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n  )\n  with check (\n    organization_id is not null\n    and organization_id::text = nullif(current_setting('app.organization_id', true), '')\n  );\n\ninsert into public.app_migrations (version, applied_at)\nvalues ('42', now())\non conflict (version) do nothing;\n"
    }
    ,
    {
      "id": "v043_qna_pairs_rpcs",
      "name": "v43 – Q&A: RPCs para inserir/bulk inserir com contexto RLS",
      "checksum": "",
      "sql": "-- v43 – Q&A: RPCs para inserir/bulk inserir com contexto RLS na mesma sessão\n\nBEGIN;\n\n-- Função para inserir único registro garantindo contexto de organização na MESMA sessão\ncreate or replace function public.qna_insert(\n  p_organization_id uuid,\n  p_pergunta text,\n  p_resposta text,\n  p_categoria text default 'Geral',\n  p_tags text[] default '{}'\n)\nreturns public.qna_pairs\nlanguage plpgsql\nas $$\ndeclare\n  rec public.qna_pairs;\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n  insert into public.qna_pairs (organization_id, pergunta, resposta, categoria, tags)\n  values (\n    p_organization_id,\n    trim(coalesce(p_pergunta, '')),\n    trim(coalesce(p_resposta, '')),\n    coalesce(nullif(trim(coalesce(p_categoria, '')), ''), 'Geral'),\n    coalesce(p_tags, '{}'::text[])\n  )\n  returning * into rec;\n  return rec;\nend;\n$$;\n\ngrant execute on function public.qna_insert(uuid, text, text, text, text[]) to anon, authenticated;\n\n-- Função bulk – insere vários itens (espera JSON array de objetos)\ncreate or replace function public.qna_bulk_upsert(\n  p_organization_id uuid,\n  p_items jsonb\n)\nreturns integer\nlanguage plpgsql\nas $$\ndeclare\n  item jsonb;\n  v_count int := 0;\n  v_tags text[];\nbegin\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n  if p_items is null or jsonb_typeof(p_items) <> 'array' then\n    return 0;\n  end if;\n  for item in select jsonb_array_elements(p_items) loop\n    v_tags := coalesce(\n      (select array_agg(value::text) from jsonb_array_elements_text(item->'tags_list')),\n      '{}'::text[]\n    );\n    insert into public.qna_pairs (organization_id, pergunta, resposta, categoria, tags)\n    values (\n      p_organization_id,\n      trim(coalesce(item->>'pergunta', '')),\n      trim(coalesce(item->>'resposta', '')),\n      coalesce(nullif(trim(coalesce(item->>'categoria', '')), ''), 'Geral'),\n      v_tags\n    )\n    on conflict do nothing;\n    v_count := v_count + 1;\n  end loop;\n  return v_count;\nend;\n$$;\n\ngrant execute on function public.qna_bulk_upsert(uuid, jsonb) to anon, authenticated;\n\nCOMMIT;\n\n-- Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('43', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v044_qna_pairs_header_ctx",
      "name": "v44 – Q&A: RLS lê header x-organization-id como fallback do app.organization_id",
      "checksum": "",
      "sql": "BEGIN;\n\n-- Habilitar RLS (idempotente)\nALTER TABLE public.qna_pairs ENABLE ROW LEVEL SECURITY;\n\n-- Recriar política de SELECT para aceitar o header OU GUC\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1 FROM pg_policies \n    WHERE schemaname='public' AND tablename='qna_pairs' AND policyname='qna_pairs_select_own_org'\n  ) THEN\n    DROP POLICY qna_pairs_select_own_org ON public.qna_pairs;\n  END IF;\nEND $$;\n\nCREATE POLICY qna_pairs_select_own_org ON public.qna_pairs\n  FOR SELECT\n  TO anon, authenticated\n  USING (\n    organization_id IS NOT NULL\n    AND organization_id::text = coalesce(\n      nullif(current_setting('request.header.x-organization-id', true), ''),\n      nullif(current_setting('app.organization_id', true), '')\n    )\n  );\n\n-- Recriar política de modificação para aceitar o header OU GUC\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1 FROM pg_policies \n    WHERE schemaname='public' AND tablename='qna_pairs' AND policyname='qna_pairs_modify_own_org'\n  ) THEN\n    DROP POLICY qna_pairs_modify_own_org ON public.qna_pairs;\n  END IF;\nEND $$;\n\nCREATE POLICY qna_pairs_modify_own_org ON public.qna_pairs\n  FOR ALL\n  TO anon, authenticated\n  USING (\n    organization_id IS NOT NULL\n    AND organization_id::text = coalesce(\n      nullif(current_setting('request.header.x-organization-id', true), ''),\n      nullif(current_setting('app.organization_id', true), '')\n    )\n  )\n  WITH CHECK (\n    organization_id IS NOT NULL\n    AND organization_id::text = coalesce(\n      nullif(current_setting('request.header.x-organization-id', true), ''),\n      nullif(current_setting('app.organization_id', true), '')\n    )\n  );\n\nCOMMIT;\n\n-- Marcar versão\nINSERT INTO public.app_migrations (version, applied_at)\nVALUES ('44', now())\nON CONFLICT (version) DO NOTHING;\n"
    },
    {
      "id": "v045_qna_list_rpc",
      "name": "v45 – Q&A: RPC qna_list (lista itens com contexto de organização na mesma sessão)",
      "checksum": "",
      "sql": "BEGIN;\n\nset search_path = public, auth;\n\n-- Função para listar Q&A garantindo contexto de organização\ncreate or replace function public.qna_list(\n  p_organization_id uuid,\n  p_query text default null,\n  p_limit int default 200,\n  p_offset int default 0\n)\nreturns setof public.qna_pairs\nlanguage plpgsql\nas $$\nbegin\n  -- Garantir contexto da organização na sessão atual (RLS)\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n\n  return query\n    select *\n    from public.qna_pairs\n    where organization_id = p_organization_id\n      and (\n        p_query is null\n        or trim(p_query) = ''\n        or (\n          to_tsvector('portuguese', coalesce(pergunta,'') || ' ' || coalesce(resposta,'') || ' ' || coalesce(categoria,''))\n          @@ plainto_tsquery('portuguese', p_query)\n        )\n      )\n    order by updated_at desc\n    limit greatest(0, coalesce(p_limit, 200))\n    offset greatest(0, coalesce(p_offset, 0));\nend;\n$$;\n\ngrant execute on function public.qna_list(uuid, text, int, int) to anon, authenticated;\n\nCOMMIT;\n\n-- Marcar versão\ninsert into public.app_migrations (version, applied_at)\nvalues ('45', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v056_rm_get_conversation_messages",
      "name": "v56 – WhatsApp Repo: RPC rm_get_conversation_messages",
      "checksum": "",
      "sql": "BEGIN;\n\n-- v56 – RPC rm_get_conversation_messages: obter mensagens por conversation_id (mesma sessão)\ncreate or replace function public.rm_get_conversation_messages(\n  p_organization_id uuid,\n  p_conversation_id text,\n  p_limit int default 200,\n  p_offset int default 0\n)\nreturns table (\n  id uuid,\n  conversation_id text,\n  content_text text,\n  sender_type public.sender_type,\n  whatsapp_cliente text,\n  whatsapp_empresa text,\n  created_at timestamptz\n)\nlanguage plpgsql\nstable\nas $$\nbegin\n  -- Garantir contexto de organização na MESMA sessão\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n\n  return query\n  select m.id,\n         m.conversation_id,\n         m.content_text,\n         m.sender_type,\n         m.whatsapp_cliente,\n         m.whatsapp_empresa,\n         m.created_at\n  from public.repositorio_de_mensagens m\n  where m.organization_id = p_organization_id\n    and m.conversation_id = p_conversation_id\n  order by m.created_at asc\n  limit greatest(p_limit, 1)\n  offset greatest(p_offset, 0);\nend;\n$$;\n\ndo $$ begin\n  grant execute on function public.rm_get_conversation_messages(uuid, text, int, int) to anon, authenticated;\nexception when others then null; end $$;\n\nCOMMIT;\n\ninsert into public.app_migrations (version, applied_at)\nvalues ('56', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v057_crm_leads_stage_case_fix",
      "name": "v57 – CRM: trigger case-insensitive para crm_leads.stage",
      "checksum": "",
      "sql": "/*\n  Case-insensitive fix for crm_leads.stage before FK check\n  - Requires unique index on (organization_id, lower(name)) in crm_stages\n  - BEFORE INSERT/UPDATE: if stage provided, replace by exact crm_stages.name\n  - Does not invent values; if no match, keeps provided value (FK will enforce)\n*/\n\nbegin;\n\n-- 1) Unique functional index to prevent duplicates by case (idempotent)\ncreate unique index if not exists crm_stages_org_lower_name_key\non public.crm_stages (organization_id, lower(name));\n\n-- 2) Function\ncreate or replace function public.trg_crm_leads_fix_stage_case()\nreturns trigger\nlanguage plpgsql\nas $$\ndeclare\n  v_name text;\nbegin\n  if new.stage is null or trim(new.stage) = '' then\n    return new;\n  end if;\n\n  select s.name into v_name\n  from public.crm_stages s\n  where s.organization_id = new.organization_id\n    and lower(s.name) = lower(new.stage)\n  limit 1;\n\n  if v_name is not null then\n    new.stage := v_name;\n  end if;\n\n  return new;\nend;\n$$;\n\n-- 3) Trigger\ndrop trigger if exists trg_crm_leads_fix_stage_case on public.crm_leads;\ncreate trigger trg_crm_leads_fix_stage_case\nbefore insert or update of stage on public.crm_leads\nfor each row\nexecute function public.trg_crm_leads_fix_stage_case();\n\ncommit;\n\n\ninsert into public.app_migrations (version, applied_at)\nvalues ('57', now())\non conflict (version) do nothing;\n"
    },
    {
      "id": "v058_crm_leads_upsert_rpc",
      "name": "v58 – CRM: RPC crm_leads_upsert (contexto + normalização)",
      "checksum": "",
      "sql": "BEGIN;\n\n-- v58 – RPC crm_leads_upsert: inserção/atualização com contexto de organização + normalização de stage\n\n-- 1) Helper (idempotente): garante a existência da função de contexto\ncreate or replace function public.set_rls_context(p_organization_id uuid)\nreturns void\nlanguage sql\nas $$\n  select set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n$$;\n\n-- 2) Remover versões anteriores (qualquer assinatura) para evitar sobrecarga\ndo $$\ndeclare r record;\nbegin\n  for r in (\n    select p.oid, pg_get_function_identity_arguments(p.oid) as args\n    from pg_proc p\n    join pg_namespace n on n.oid = p.pronamespace\n    where n.nspname = 'public' and p.proname = 'crm_leads_upsert'\n  ) loop\n    execute format('drop function if exists public.crm_leads_upsert(%s);', r.args);\n  end loop;\nend $$;\n\n-- 3) RPC principal (atenção à ordem: argumentos obrigatórios primeiro)\n\ncreate or replace function public.crm_leads_upsert(\n  p_organization_id uuid,\n  p_name text,\n  p_id uuid default null,\n  p_whatsapp text default null,\n  p_email text default null,\n  p_instagram_username text default null,\n  p_stage text default null,\n  p_value numeric(10,2) default 0,\n  p_priority text default 'medium',\n  p_source text default null,\n  p_canal text default null,\n  p_has_payment boolean default false,\n  p_payment_value numeric(10,2) default 0,\n  p_sold_produto_servico_id uuid default null,\n  p_sold_quantity integer default 1,\n  p_interest_produto_servico_id uuid default null,\n  p_interest_quantity integer default 1,\n  p_custom_fields jsonb default '{}'::jsonb,\n  p_created_at timestamptz default null,\n  p_updated_at timestamptz default null\n)\nreturns public.crm_leads\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\ndeclare\n  v_stage text;\n  rec public.crm_leads;\nbegin\n  -- 2.1) Contexto de organização na MESMA sessão\n  perform set_config('app.organization_id', coalesce(p_organization_id::text, ''), true);\n\n  -- 2.2) Normalização de stage (case-insensitive) para o name exato da organização\n  if p_stage is not null and trim(p_stage) <> '' then\n    select s.name into v_stage\n    from public.crm_stages s\n    where s.organization_id = p_organization_id\n      and lower(s.name) = lower(p_stage)\n    limit 1;\n  end if;\n\n  -- Se não matchar, manter NULL para não violar a FK\n  if v_stage is null and (p_stage is null or trim(p_stage) = '') then\n    v_stage := null;\n  end if;\n\n  if p_id is null then\n    -- INSERT\n    insert into public.crm_leads (\n      organization_id, name, whatsapp, email, instagram_username, stage,\n      description, value, priority, source, canal,\n      has_payment, payment_value, sold_produto_servico_id, sold_quantity,\n      interest_produto_servico_id, interest_quantity, custom_fields,\n      created_at, updated_at\n    ) values (\n      p_organization_id,\n      trim(coalesce(p_name, '')),\n      nullif(trim(coalesce(p_whatsapp, '')), ''),\n      nullif(trim(coalesce(p_email, '')), ''),\n      nullif(trim(coalesce(p_instagram_username, '')), ''),\n      coalesce(v_stage, null),\n      null,\n      coalesce(p_value, 0),\n      coalesce(nullif(trim(p_priority), ''), 'medium'),\n      nullif(trim(coalesce(p_source, '')), ''),\n      nullif(trim(coalesce(p_canal, '')), ''),\n      coalesce(p_has_payment, false),\n      coalesce(p_payment_value, 0),\n      p_sold_produto_servico_id,\n      greatest(coalesce(p_sold_quantity, 1), 1),\n      p_interest_produto_servico_id,\n      greatest(coalesce(p_interest_quantity, 1), 1),\n      coalesce(p_custom_fields, '{}'::jsonb),\n      coalesce(p_created_at, now()),\n      coalesce(p_updated_at, now())\n    ) returning * into rec;\n  else\n    -- UPDATE\n    update public.crm_leads set\n      name = trim(coalesce(p_name, name)),\n      whatsapp = coalesce(nullif(trim(coalesce(p_whatsapp, '')), ''), whatsapp),\n      email = coalesce(nullif(trim(coalesce(p_email, '')), ''), email),\n      instagram_username = coalesce(nullif(trim(coalesce(p_instagram_username, '')), ''), instagram_username),\n      stage = coalesce(v_stage, stage),\n      value = coalesce(p_value, value),\n      priority = coalesce(nullif(trim(p_priority), ''), priority),\n      source = coalesce(nullif(trim(coalesce(p_source, '')), ''), source),\n      canal = coalesce(nullif(trim(coalesce(p_canal, '')), ''), canal),\n      has_payment = coalesce(p_has_payment, has_payment),\n      payment_value = coalesce(p_payment_value, payment_value),\n      sold_produto_servico_id = coalesce(p_sold_produto_servico_id, sold_produto_servico_id),\n      sold_quantity = greatest(coalesce(p_sold_quantity, sold_quantity, 1), 1),\n      interest_produto_servico_id = coalesce(p_interest_produto_servico_id, interest_produto_servico_id),\n      interest_quantity = greatest(coalesce(p_interest_quantity, interest_quantity, 1), 1),\n      custom_fields = coalesce(p_custom_fields, custom_fields),\n      updated_at = coalesce(p_updated_at, now())\n    where id = p_id and organization_id = p_organization_id\n    returning * into rec;\n  end if;\n\n  return rec;\nend;\n$$;\n\ndo $$ begin\n  grant execute on function public.crm_leads_upsert(\n    uuid, text, uuid, text, text, text, text, numeric, text, text, text, boolean, numeric, uuid, integer, uuid, integer, jsonb, timestamptz, timestamptz\n  ) to anon, authenticated;\nexception when others then null; end $$;\n\nCOMMIT;\n\ninsert into public.app_migrations (version, applied_at)\nvalues ('58', now())\non conflict (version) do nothing;\n"
    }
  ]
}


